# app/services/overmind/orchestrator.py
# =================================================================================================
# OVERMIND ORCHESTRATOR – COGNITIVE CORE (العقل المدبر)
# Version: 13.0.0-super-intelligence (Refactored)
# =================================================================================================

import asyncio
import logging
from typing import Any

from app.core.protocols import AgentExecutor, AgentPlanner, AgentReflector
from app.models import Mission, MissionEventType, MissionStatus, TaskStatus
from app.services.overmind.domain.cognitive import SuperBrain
from app.services.overmind.state import MissionStateManager

logger = logging.getLogger(__name__)


class OvermindOrchestrator:
    """
    العقل المدبر (Overmind Orchestrator).

    هذا الكلاس هو "المنسق" الذي يدير دورة حياة المهمة.
    يعتمد على مبادئ SOLID لفصل المسؤوليات:
    - SuperBrain: للتخطيط والنقد (Thinking).
    - AgentExecutor: للتنفيذ (Doing).
    - MissionStateManager: للذاكرة (Memory).

    المبدأ الفلسفي: "فكر، انتقد، نفذ، تعلم".
    """

    def __init__(
        self,
        state_manager: MissionStateManager,
        executor: AgentExecutor,
        planner: AgentPlanner,
        reflector: AgentReflector,
    ):
        """
        تهيئة العقل المدبر باستخدام حقن التبعيات (DIP).
        """
        self.state = state_manager
        self.executor = executor
        # تكوين الدماغ الخارق (SuperBrain) الذي يجمع بين التخطيط والنقد
        self.brain = SuperBrain(planner, reflector)

    async def run_mission(self, mission_id: int) -> None:
        """
        نقطة الانطلاق الرئيسية للمهمة.
        """
        try:
            mission = await self.state.get_mission(mission_id)
            if not mission:
                logger.error(f"Mission {mission_id} not found in memory.")
                return

            await self._run_lifecycle_loop(mission_id)

        except Exception as e:
            logger.exception(f"Fatal error in Mission {mission_id}")
            await self._handle_catastrophic_failure(mission_id, e)

    async def _run_lifecycle_loop(self, mission_id: int) -> None:
        """
        حلقة الذكاء والتنفيذ.
        The Cognitive Loop: Observe -> Think -> Critique -> Act -> Reflect.
        """
        MAX_CYCLES = 2000
        CYCLE_DELAY = 0.5

        logger.info(f"Overmind: Starting cognitive loop for Mission {mission_id}")

        for cycle in range(MAX_CYCLES):
            mission = await self.state.get_mission(mission_id)
            if not mission:
                break

            status = mission.status
            logger.debug(f"Cycle {cycle}: Mission Status = {status}")

            if status == MissionStatus.PENDING:
                # مرحلة التفكير والتخطيط والنقد
                await self._phase_thinking(mission)

            elif status == MissionStatus.PLANNING:
                await asyncio.sleep(CYCLE_DELAY)

            elif status == MissionStatus.PLANNED:
                await self._phase_prepare_execution(mission)

            elif status == MissionStatus.RUNNING:
                is_finished = await self._phase_execution_monitor(mission)
                if is_finished:
                    break
                await asyncio.sleep(CYCLE_DELAY)

            elif status in (MissionStatus.SUCCESS, MissionStatus.FAILED, MissionStatus.CANCELED):
                break
            else:
                await asyncio.sleep(CYCLE_DELAY)

    async def _phase_thinking(self, mission: Mission) -> None:
        """
        مرحلة التفكير العميق (Thinking Phase).
        تتضمن التخطيط والنقد الذاتي (Self-Reflection).
        """
        logger.info(f"Overmind: Thinking about Mission {mission.id}...")
        await self.state.update_mission_status(
            mission.id, MissionStatus.PLANNING, "Thinking & Critiquing..."
        )

        try:
            # استخدام الدماغ الخارق للتفكير
            plan_result = await self.brain.think_and_plan(mission.objective)

            meta = plan_result.get("meta", {})
            status = meta.get("status")

            if status == "needs_refinement":
                # في المستقبل، يمكننا إضافة منطق لإعادة التخطيط هنا.
                # حالياً، سنقبل الخطة مع تحذير.
                logger.warning("Proceeding with a plan that needs refinement.")

            # حفظ الخطة
            await self.state.persist_plan(
                mission.id,
                planner_name="SuperBrain",
                plan_schema=plan_result,
                score=1.0,
                rationale="Generated by SuperBrain with Self-Reflection",
            )

            await self.state.update_mission_status(
                mission.id, MissionStatus.PLANNED, "Plan Optimized & Approved."
            )

        except Exception as e:
            logger.error(f"Thinking failed: {e}")
            await self.state.update_mission_status(
                mission.id, MissionStatus.FAILED, f"Brain Failure: {e}"
            )

    async def _phase_prepare_execution(self, mission: Mission) -> None:
        logger.info(f"Overmind: Engaging execution engines for Mission {mission.id}")
        await self.state.update_mission_status(
            mission.id, MissionStatus.RUNNING, "Execution Started"
        )

    async def _phase_execution_monitor(self, mission: Mission) -> bool:
        """
        مراقب التنفيذ.
        """
        tasks = await self.state.get_tasks(mission.id)

        pending_tasks = [t for t in tasks if t.status == TaskStatus.PENDING]
        running_tasks = [t for t in tasks if t.status == TaskStatus.RUNNING]
        failed_tasks = [t for t in tasks if t.status == TaskStatus.FAILED]

        if not pending_tasks and not running_tasks:
            if failed_tasks:
                await self.state.update_mission_status(
                    mission.id, MissionStatus.FAILED, f"Mission Failed: {len(failed_tasks)} tasks failed."
                )
            else:
                await self.state.update_mission_status(
                    mission.id, MissionStatus.SUCCESS, "Mission Accomplished successfully."
                )
            return True

        task_map = {t.task_key: t for t in tasks}
        ready_to_run = []

        for task in pending_tasks:
            dependencies = task.depends_on_json or []
            can_run = True
            for dep_key in dependencies:
                parent_task = task_map.get(dep_key)
                if not parent_task or parent_task.status != TaskStatus.SUCCESS:
                    can_run = False
                    break
            if can_run:
                ready_to_run.append(task)

        MAX_PARALLEL = 5
        batch = ready_to_run[:MAX_PARALLEL]

        if batch:
            coroutines = [self._execute_single_task(t) for t in batch]
            await asyncio.gather(*coroutines)

        return False

    async def _execute_single_task(self, task: Any) -> None:
        try:
            await self.state.mark_task_running(task.id)
            result = await self.executor.execute_task(task)

            if result["status"] == "success":
                await self.state.mark_task_complete(
                    task.id,
                    result_text=result["result_text"],
                    meta=result.get("meta", {})
                )
            else:
                await self.state.mark_task_failed(task.id, result.get("error", "Unknown Error"))

        except Exception as e:
            logger.error(f"Task Execution Crashed: {e}")
            await self.state.mark_task_failed(task.id, f"Crash: {str(e)}")

    async def _handle_catastrophic_failure(self, mission_id: int, error: Exception) -> None:
        await self.state.update_mission_status(
            mission_id, MissionStatus.FAILED, f"System Crash: {error}"
        )
