system_principles:
  - number: 1
    statement: "تعدد الأشكال في البرمجة كائنية التوجه يسمح بواجهة واحدة لاستدعاء عمليات متعددة حسب نوع الكائن وقت التنفيذ."
  - number: 2
    statement: "لا يمكن إنشاء كائن (Instance) مباشرةً من فئة مجردة (Abstract Class)."
  - number: 3
    statement: "الوراثة تتيح إعادة استخدام الشيفرة عبر إنشاء فئة جديدة تعتمد على خصائص وسلوك فئة موجودة."
  - number: 4
    statement: "التغليف (Encapsulation) يعني إخفاء التفاصيل الداخلية للكائن وإظهار واجهة محددة للتعامل معه."
  - number: 5
    statement: "الدالة النقية لا تقوم بتعديل متغيرات عامة أو إحداث تأثيرات جانبية على حالة خارجية."
  - number: 6
    statement: "الدالة عالية الرتبة (Higher-Order Function) هي دالة تأخذ دوالًا كوسائط أو تُرجع دالة كنتيجة."
  - number: 7
    statement: "التقييم الكسول (Lazy Evaluation) يعني تأجيل حساب التعبير حتى الحاجة الفعلية لقيمته."
  - number: 8
    statement: "عدم قابلية التغيير (Immutability) يساعد على تجنب الاعتماد على حالة متغيرة أثناء التنفيذ كما في البرمجة الوظيفية."
  - number: 9
    statement: "الكومة الثنائية (Binary Heap) مناسبة لتنفيذ صف ذي أولوية (Priority Queue) للحصول على أعلى أولوية بكفاءة."
  - number: 10
    statement: "بنية Trie (Prefix Tree) تخزن الكلمات حسب البادئات وتتيح البحث بكفاءة اعتمادًا على البادئة."
  - number: 11
    statement: "البحث بعرض (BFS) يستخدم صفًّا (Queue) لزيارة العقد مستوىً بمستوى."
  - number: 12
    statement: "جدول التجزئة (Hash Table) يخزن أزواج المفتاح/القيمة ويتيح البحث بكفاءة عالية بمتوسط زمن قريب من O(1)."
  - number: 13
    statement: "شجرة AVL هي شجرة بحث ثنائية ذاتية الاتزان تضمن عمليات O(log n) في أسوأ الأحوال."
  - number: 14
    statement: "البرمجة الديناميكية (Dynamic Programming) تحل المشكلة عبر مشاكل فرعية وتخزن النتائج لتجنب إعادة الحساب."
  - number: 15
    statement: "خوارزمية Backtracking تبني الحل تدريجيًا وتتراجع عند اكتشاف أن المسار الحالي لن يؤدي إلى حل صحيح."
  - number: 16
    statement: "تعقيد البحث الثنائي (Binary Search) في قائمة مرتبة هو O(log n)."
  - number: 17
    statement: "الخوارزميات الجشعة (Greedy) تتخذ قرارًا محليًا أفضل في كل خطوة على أمل الوصول لحل عالمي جيد."
  - number: 18
    statement: "حالة السباق (Race Condition) تحدث عندما تتنافس خيوط متعددة على مورد مشترك فتنتج نتائج غير متوقعة."
  - number: 19
    statement: "خيوط العملية الواحدة تشترك في نفس مساحة الذاكرة، بينما العمليات المنفصلة تملك ذاكرة معزولة."
  - number: 20
    statement: "القفل (Mutex) يمنع دخول أكثر من خيط إلى القسم الحرج في الوقت نفسه ويساعد على منع السباقات."
  - number: 21
    statement: "Singleton مثال على نمط تصميم من أنماط عصابة الأربعة (GoF)."
  - number: 22
    statement: "نمط Observer يقوم فيه الـSubject بإخطار الـObservers عند تغيّر حالته."
  - number: 23
    statement: "مبادئ SOLID الخمسة تهدف لتحسين قابلية الفهم والتطوير والصيانة في التصميم الكائني."
  - number: 24
    statement: "نظرية CAP تشير إلى: الاتساق (Consistency) والتوافرية (Availability) وتحمل التقسيم (Partition Tolerance)."
  - number: 25
    statement: "RPC يسمح باستدعاء إجراء على خادم بعيد كما لو كان استدعاءً محليًا."
  - number: 26
    statement: "طوابير الرسائل تفصل المكونات عبر تواصل غير متزامن وتمكّن اختلاف سرعات المنتج والمستهلك دون فقد البيانات."
  - number: 27
    statement: "Git نظام تحكم إصدارات موزع لتتبع وإدارة تاريخ الشيفرة المصدرية."
  - number: 28
    statement: "Docker يوفّر حاويات لتشغيل التطبيق مع تبعياته في بيئة معزولة تشارك نواة النظام المضيف."
  - number: 29
    statement: "CI/CD تعني التكامل المستمر والتسليم المستمر (وأحيانًا النشر المستمر)."
  - number: 30
    statement: "Haskell تُعد لغة وظيفية خالصة (Purely Functional) بشكل افتراضي مع تقييم كسول."
  - number: 31
    statement: "جعل Square يرث من Rectangle مع تغيير سلوك setWidth/setHeight يخرق مبدأ استبدال ليسكوف (LSP) لأنه يمنع الاستبدال الآمن."
  - number: 32
    statement: "مبدأ Open/Closed ينص على أن الكيانات البرمجية مفتوحة للإضافة ومغلقة للتعديل."
  - number: 33
    statement: "Java لا تدعم الوراثة المتعددة للفئات مباشرةً لتجنب غموض مشكلة الماس."
  - number: 34
    statement: "مبدأ Dependency Inversion يفرض أن تعتمد الوحدات على التجريدات لا على التفاصيل، وأن تعتمد التفاصيل أيضًا على التجريدات."
  - number: 35
    statement: "الدالة عديمة الآثار الجانبية لا تغيّر حالة خارجية (مثل متغير عام أو ملف أو طباعة)، وهذا يجعلها أسهل للاختبار والتوازي والتنبؤ."
  - number: 36
    statement: "التقييم الكسول في Haskell يسمح بتعريف بنى بيانات لانهائية لأن القيم لا تُحسب إلا عند الحاجة."
  - number: 37
    statement: "العودية (Recursion) تُستخدم كثيرًا بدل الحلقات في البرمجة الوظيفية."
  - number: 38
    statement: "عقدة B-Tree قد تحتوي عدة مفاتيح وعدة أبناء، ما يقلل ارتفاع الشجرة مقارنةً بـBST."
  - number: 39
    statement: "Trie هي الأنسب للبحث بحسب بادئة نصية كما في الإكمال التلقائي."
  - number: 40
    statement: "خوارزمية Dijkstra لا تعمل بشكل صحيح بوجود أوزان سالبة."
  - number: 41
    statement: "معالجة تصادمات Hash يمكن أن تتم عبر Chaining (قائمة/بنية لكل خانة) أو Open Addressing (البحث عن خانة بديلة وفق نمط)."
  - number: 42
    statement: "البرمجة الديناميكية تتطلب Optimal Substructure وتداخل المشاكل الفرعية (Overlapping Subproblems)."
  - number: 43
    statement: "الخوارزمية التقريبية لمسألة NP-صعبة قد لا تعطي الحل الأمثل لكنها تضمن حدًا/نسبة تقريب بالنسبة للأمثل."
  - number: 44
    statement: "الشيفرة ذات الحلقة المثلثية (j من 1 إلى i) تعقيدها الكلي من رتبة O(n^2)."
  - number: 45
    statement: "QuickSort متوسطه O(n log n) وقد يصبح O(n^2) في أسوأ الحالات عند اختيار Pivot سيئ باستمرار."
  - number: 46
    statement: "Deadlock يحدث عندما تنتظر خيوط متعددة موارد يحتجزها بعضها البعض بشكل دائري فلا يتقدم أي خيط."
  - number: 47
    statement: "نموذج Actor يعتمد على تمرير الرسائل دون مشاركة حالة مباشرة بين المكونات."
  - number: 48
    statement: "مثال Race Condition: خيطان يزيدان counter في نفس الوقت فيضيع أحد التحديثين، ويُمنع ذلك بقفل Mutex أو عمليات ذرّية (Atomic)."
  - number: 49
    statement: "Concurrency تعني تداخل المهام منطقيًا، وParallelism تعني تنفيذها فعليًا في نفس اللحظة على أكثر من نواة/معالج."
  - number: 50
    statement: "نمط Strategy يتيح تبديل خوارزميات قابلة للتبادل أثناء التشغيل دون تغيير الكود العميل."
  - number: 51
    statement: "Reactive Programming تعتمد على تدفقات بيانات غير متزامنة تنشر التغيّرات تلقائيًا للمشتركين."
  - number: 52
    statement: "MVC يفصل Model عن View وعن Controller لتحسين التنظيم والصيانة."
  - number: 53
    statement: "Eventual Consistency تعني أن العقد ستتوافق في النهاية إذا توقفت التحديثات الجديدة."
  - number: 54
    statement: "2PC يضمن ذرّية المعاملة الموزعة بحيث تُعتمد لدى الجميع أو تُلغى لدى الجميع وفق قرار منسّق."
  - number: 55
    statement: "Strong Consistency تضمن رؤية أحدث كتابة فورًا، بينما Eventual Consistency قد تُظهر قراءات قديمة مؤقتًا ثم تتقارب لاحقًا."
  - number: 56
    statement: "زمن الشبكة (Latency) قد يؤثر بشدة على أداء وصحة الأنظمة الموزعة ويجب تصميم النظام مع افتراض وجود تأخير."
  - number: 57
    statement: "VM تشغّل نظام تشغيل كاملًا لكل آلة افتراضية، بينما Container يشغّل التطبيق وتبعياته مع مشاركة نواة المضيف وبكلفة أخف."
  - number: 58
    statement: "Kubernetes منصة شائعة لأتمتة نشر وإدارة حاويات Docker مع التوسع والتعافي الذاتي."
  - number: 59
    statement: "CI يدمج ويختبر باستمرار، وCD يجهّز النشر باستمرار (أو ينشر تلقائيًا في حالة Continuous Deployment)."
  - number: 60
    statement: "Profiling يقيس استهلاك الموارد لتحديد اختناقات الأداء مثل دوال تستهلك أكثر وقت CPU أو ذاكرة."
  - number: 61
    statement: "Design by Contract يحدد شروطًا مسبقة ولاحقة وثوابت صنف لضمان صحة السلوك ورفع موثوقية البرمجية."
  - number: 62
    statement: "مشكلة الماس في الوراثة المتعددة تنشأ عندما تتقاطع وراثتان من أصل مشترك فتظهر إشكالية أي نسخة من الأساس تُستخدم."
  - number: 63
    statement: "الشيفرة C++ ستطبع “Derived” لأن foo افتراضية وسيتم الربط ديناميكيًا حسب النوع الفعلي للكائن."
  - number: 64
    statement: "مبدأ Interface Segregation ينص على ألا يُجبر العملاء على الاعتماد على واجهات لا يحتاجونها."
  - number: 65
    statement: "مبدأ المسؤولية الواحدة (SRP) يعني أن لكل صنف سببًا واحدًا للتغيير مما يقلل التعقيد ويزيد قابلية الصيانة."
  - number: 66
    statement: "الموناد (Monad) هي بنية تربط عمليات في سياق (مثل Maybe أو IO) عبر bind/return لتسلسل العمليات دون معالجة السياق يدويًا كل مرة."
  - number: 67
    statement: "Eager Evaluation يحسب القيم فورًا وهو أسهل للتنبؤ بالأداء، بينما Lazy Evaluation يؤجل الحساب وقد يوفر عملًا لكنه قد يصعّب توقع الذاكرة والزمن."
  - number: 68
    statement: "الدوال النقية والبيانات غير القابلة للتغيير تسهّل التوازي لأن غياب الآثار الجانبية يقلل الحاجة للتزامن."
  - number: 69
    statement: "Tail Recursion Optimization يحول الاستدعاء الذاتي الأخير إلى شكل حلقي لتقليل استهلاك المكدس ومنع Stack Overflow."
  - number: 70
    statement: "التعبير take 5 (iterate (+1) 0) ينتج [0,1,2,3,4] لأن iterate تولد قائمة لانهائية وtake يأخذ أول خمسة عناصر فقط."
  - number: 71
    statement: "Trie مناسبة للإكمال التلقائي لأنها تجعل زمن البحث مرتبطًا بطول البادئة وتسمح باستعراض كل الكلمات تحت عقدة البادئة."
  - number: 72
    statement: "Hash Table متوسطه O(1) لكن أسوأه قد يصل O(n)، بينما الشجرة المتوازنة تضمن O(log n) في أسوأ الحالات."
  - number: 73
    statement: "Trie قد تستهلك ذاكرة أكبر عندما تكون مجموعة الكلمات كبيرة والتشارك في البادئات قليل."
  - number: 74
    statement: "B-Tree ذات تفرع عالٍ تقلل عمق الشجرة وعدد عمليات I/O على القرص لذا تناسب قواعد البيانات والتخزين الخارجي."
  - number: 75
    statement: "أفضل نهج لاستخراج أكبر 10 قيم من مليون عنصر هو الاحتفاظ بـMin-Heap بحجم 10 أثناء المرور لتحقيق O(n log 10)."
  - number: 76
    statement: "NP-Complete تعني أن المسألة في NP وكل مسائل NP يمكن اختزالها إليها، ولا يُعرف حل متعدد الحدود لها عمومًا."
  - number: 77
    statement: "Memoization أسلوب Top-Down مع كاش لنتائج الاستدعاءات العودية، وTabulation أسلوب Bottom-Up يبني جدولًا من الحالات الأصغر للأكبر."
  - number: 78
    statement: "إذا تضاعف n وزاد الزمن إلى 8× فالتعقيد المرجح هو O(n^3)."
  - number: 79
    statement: "مثال خوارزمية تقريبية: Vertex Cover بخوارزمية تقريب 2-Approx التي تختار طرفي ضلع غير مغطى وتكرر حتى تغطية كل الأضلاع."
  - number: 80
    statement: "Bellman-Ford تصلح لإيجاد أقصر مسارات مع أوزان سالبة طالما لا توجد دورات سالبة."
  - number: 81
    statement: "Semaphore يدير عددًا من “التصاريح” لمورد محدود، بينما Mutex قفل حصري لمورد واحد عادةً؛ مثلًا Semaphore بقيمة 3 يحد عدد الاتصالات المتزامنة إلى 3."
  - number: 82
    statement: "Data Parallelism يعني نفس العملية على أجزاء بيانات مختلفة (مثل جمع أجزاء مصفوفة)، وTask Parallelism يعني مهام مختلفة بالتوازي (مثل معالجة لون الصورة وتطبيق فلتر في آن واحد)."
  - number: 83
    statement: "قانون أمدال يحدد حدًا أعلى للتسريع بسبب الجزء المتسلسل الذي لا يمكن موازنته بالكامل."
  - number: 84
    statement: "GIL في CPython يمنع تنفيذ بايت كود بايثون في أكثر من خيط في نفس الوقت داخل نفس العملية، ما يحد من توازي المهام الحسابية."
  - number: 85
    statement: "Go تستخدم goroutines خفيفة وChannels للتواصل بأسلوب مستوحى من CSP عبر تمرير الرسائل بدل مشاركة الذاكرة."
  - number: 86
    statement: "Clean Architecture تعزل منطق الأعمال في الداخل وتفرض قاعدة الاعتماد بأن تتجه الاعتماديات نحو الداخل فقط لا نحو التفاصيل الخارجية."
  - number: 87
    statement: "Backpressure آلية لضبط تدفق البيانات عندما يكون المستهلك أبطأ من المنتج لتجنب الانهيار أو نفاد الذاكرة."
  - number: 88
    statement: "Dependency Injection يحقق DIP عمليًا بتمرير التبعيات من الخارج بدل إنشائها داخليًا، مما يقلل الاقتران ويسهّل الاختبار."
  - number: 89
    statement: "نمط Visitor يسمح بإضافة عمليات جديدة على كائنات متعددة دون تعديل تعريف هذه الكائنات عبر “زائر” ينفذ العمليات عليها."
  - number: 90
    statement: "Loose Coupling يعني اعتمادًا ضعيفًا بين المكونات عبر واجهات وتجريدات بحيث يمكن تغيير جزء دون كسر بقية النظام."
  - number: 91
    statement: "ACID يركز على الذرية والاتساق والعزل والدوام، بينما BASE يركز على التوافر الأساسي والحالة المرنة والاتساق النهائي في بعض NoSQL."
  - number: 92
    statement: "2PC يعمل بمرحلة Prepare للتصويت ثم مرحلة Commit/Abort لضمان أن الجميع يلتزم أو الجميع يتراجع."
  - number: 93
    statement: "نظام مصرفي غالبًا يفضل CP (اتساق + تحمل تقسيم) حتى لو ضحّى بالتوافرية أثناء الانقسام لتجنب أخطاء مالية."
  - number: 94
    statement: "Message Queue تفصل الخدمات وتزيد المرونة والتوسع عبر تخزين الرسائل ومعالجتها لاحقًا وتمكين زيادة عدد المستهلكين عند الذروة."
  - number: 95
    statement: "Idempotence مهمة لأنها تسمح بإعادة إرسال الطلبات أو تكرار التنفيذ عند الفشل دون مضاعفة الأثر النهائي."
  - number: 96
    statement: "git merge يدمج التاريخ مع Merge Commit ويحافظ على التشعب، بينما git rebase يعيد كتابة التاريخ ليصبح خطيًا ويُفضّل على الفروع الخاصة قبل مشاركتها."
  - number: 97
    statement: "Kubernetes يوفّر Self-healing بإعادة تشغيل الحاويات أو إعادة جدولة Pods عند الفشل للحفاظ على توفر الخدمة."
  - number: 98
    statement: "Blue-Green Deployment يستخدم بيئتين متطابقتين ويحوّل المرور من القديمة للجديدة دفعة واحدة لتقليل التوقف وتسهيل الرجوع السريع."
  - number: 99
    statement: "Distributed Tracing يربط الطلب عبر الخدمات باستخدام Trace ID وSpans ليُظهر أين حدث التأخير أو الخطأ داخل سلسلة الخدمات."
  - number: 100
    statement: "Logging وMonitoring وDistributed Tracing تشكل معًا أعمدة Observability لفهم الحالة الداخلية للنظام وتشخيص الأعطال بسرعة."

architecture_principles:
  - number: 1
    statement: "لا يمكن بناء نظام حقيقي يتحمل آلاف المستخدمين ويحافظ على بياناتهم دون فهمٍ معماري واضح يسبق كتابة الكود."
  - number: 2
    statement: "التصميم المعماري هو خارطة قرار تحدد مكوّنات النظام وحدودها وتدفق البيانات بينها قبل التنفيذ."
  - number: 3
    statement: "القفز مباشرةً إلى البرمجة دون توثيق المتطلبات يؤدي غالبًا إلى إعادة البناء عند أول تغيير كبير."
  - number: 4
    statement: "تدفق البيانات (Data Flow) يجب أن يُعرَّف مبكرًا لأنّه يحدد أين تُنشأ البيانات وأين تُعالج وأين تُخزَّن."
  - number: 5
    statement: "المتطلبات غير الوظيفية مثل الأداء والأمن والتوسع ليست تفاصيل ثانوية بل تُحدد شكل المعمارية من البداية."
  - number: 6
    statement: "أي ميزة جديدة ستكشف عيوب التصميم إذا لم تكن حدود المسؤوليات بين المكوّنات واضحة."
  - number: 7
    statement: "التخطيط المعماري الجيد يقلل أثر التغيير (Change Impact) ويمنع انهيار أجزاء غير مرتبطة عند إضافة ميزة."
  - number: 8
    statement: "التصميم عالي المستوى يحدد الخدمات والمكوّنات والواجهات، بينما التصميم منخفض المستوى يحدد تفاصيل التنفيذ داخل كل مكوّن."
  - number: 9
    statement: "وجود وثائق تصميم مختصرة لكن دقيقة يمنع “المعرفة القبلية” ويُسهل دخول أعضاء جدد للفريق."
  - number: 10
    statement: "إعادة بناء النظام من الصفر غالبًا علامة على أن نموذج البيانات والحدود المعمارية صُممت بعشوائية في البداية."
  - number: 11
    statement: "أدوات الذكاء الاصطناعي تزيد السرعة لكنها لا تعوّض فهم المطوّر لمتطلبات النظام وقيوده."
  - number: 12
    statement: "الكود الذي يولّده الذكاء الاصطناعي قد يبدو صحيحًا محليًا لكنه قد يكون خاطئًا ضمن سياق النظام ككل."
  - number: 13
    statement: "الذكاء الاصطناعي لا يضمن الالتزام بمعايير الأمان والحوكمة والامتثال ما لم يحددها مهندس يفهمها."
  - number: 14
    statement: "بناء نظام قابل للتوسع يحتاج قرارات معمارية، والذكاء الاصطناعي لا يتحمل مسؤولية هذه القرارات عنك."
  - number: 15
    statement: "الاعتماد على الـPrompts دون مراجعة هندسية ينتج “نظامًا متشابكًا” يصعب صيانته واختباره."
  - number: 16
    statement: "دور الذكاء الاصطناعي الأفضل هو مساعدتك في التنفيذ، بينما دورك أنت هو التصميم والتحقق والقرار."
  - number: 17
    statement: "أي مخرجات ذكاء اصطناعي يجب أن تمر بمراجعة كود واختبارات وتدقيق أمني قبل اعتمادها."
  - number: 18
    statement: "الذكاء الاصطناعي لا يعرف أولويات العمل ولا مخاطر التغيير في الإنتاج مثل فريق المنتج والهندسة."
  - number: 19
    statement: "استخدام الذكاء الاصطناعي بوعي يعني تزويده بسياق معماري واضح وقيود صارمة ثم التحقق من النتائج."
  - number: 20
    statement: "لا يوجد “Prompt” يعوض غياب نموذج بيانات صحيح أو غياب تصميم لمعالجة الدفع والاسترجاع."
  - number: 21
    statement: "تصميم النظام هو تحويل المتطلبات إلى مكوّنات وواجهات وقرارات تخزين واتصال قابلة للتنفيذ."
  - number: 22
    statement: "جمع المتطلبات يتضمن تحديد الكيانات الأساسية والأحداث والسيناريوهات والحالات الاستثنائية قبل اختيار التقنية."
  - number: 23
    statement: "الأداء والأمن وقابلية التوسع والموثوقية تُعد متطلبات غير وظيفية يجب تحديدها صراحة."
  - number: 24
    statement: "التصميم المعماري يحدد حدود الخدمات أو الطبقات ويمنع تضخم “خدمة كل شيء” أو “جدول كل شيء”."
  - number: 25
    statement: "مخطط المكوّنات يوضح من يستدعي من، ومخطط تدفق البيانات يوضح ماذا ينتقل وأين يتم حفظه."
  - number: 26
    statement: "توثيق واجهات الـAPI مبكرًا يمنع اختلاف التوقعات بين الواجهة الأمامية والخلفية والخدمات الأخرى."
  - number: 27
    statement: "التفكير المستقبلي يعني تصميمًا يسمح بإضافة ميزات دون كسر البيانات التاريخية أو تغيير جذري في التخزين."
  - number: 28
    statement: "نموذج البيانات هو العمود الفقري للنظام لأن معظم الميزات تعتمد على صحة العلاقات بين الكيانات."
  - number: 29
    statement: "عدم وجود توثيق معماري يجعل النظام “قائمًا على الذاكرة البشرية” وهي مخاطرة تشغيلية كبيرة."
  - number: 30
    statement: "نجاح النظام لا يقاس بسرعة الإطلاق فقط بل بقدرة الفريق على التطوير بثبات بعد الإطلاق."
  - number: 31
    statement: "التطبيع (Normalization) يعني فصل البيانات إلى جداول تمثل كيانات مستقلة لتقليل التكرار ومنع التناقض."
  - number: 32
    statement: "قاعدة “جدول واحد لكل كيان” تجعل البيانات أوضح وتقلل أخطاء التعديل غير المقصود."
  - number: 33
    statement: "تخزين العميل والخدمة والسعر والحالة في جدول واحد يؤدي إلى تكرار البيانات وتضاربها مع الزمن."
  - number: 34
    statement: "الدمج العشوائي للحقول في جدول واحد يسبب صعوبة إضافة ميزات مثل الاسترجاع والمدفوعات والتقارير."
  - number: 35
    statement: "فصل الجداول يسمح بفرض قيود تكامل مرجعي تمنع وجود حجوزات بلا عميل أو مدفوعات بلا طلب."
  - number: 36
    statement: "المفتاح الأساسي (Primary Key) معرف فريد لكل صف ويجب أن يكون ثابتًا وغير قابل للتغيير."
  - number: 37
    statement: "المفتاح الأجنبي (Foreign Key) يربط صفًا بصف آخر ويحمي من الروابط الوهمية والأخطاء المنطقية."
  - number: 38
    statement: "وجود جدول Customers مستقل يمنع تكرار العميل ويجعل جميع حجوزاته قابلة للتجميع بسهولة."
  - number: 39
    statement: "تكرار بيانات العميل في حجوزات متعددة يخلق عملاء مكررين ويؤدي لضياع الحجوزات عند التحديث أو الدمج."
  - number: 40
    statement: "التكرار (Redundancy) يرفع احتمال التناقض لأن تعديل نسخة واحدة لا يضمن تعديل النسخ الأخرى."
  - number: 41
    statement: "القيود الفريدة (Unique) تمنع تسجيل نفس البريد أو رقم الهوية أكثر من مرة عندما يكون ذلك مطلوبًا."
  - number: 42
    statement: "استخدام نص طويل كمفتاح ربط أبطأ وأثقل على الفهارس من استخدام معرف رقمي قصير."
  - number: 43
    statement: "الاعتماد على النصوص بدل IDs يزيد حجم الفهرس ويبطئ المقارنات ويزيد فرص الأخطاء الإملائية والتباينات."
  - number: 44
    statement: "مخطط ERD قبل التنفيذ يساعد على اكتشاف نواقص الكيانات والعلاقات مثل غياب جدول المدفوعات."
  - number: 45
    statement: "العلاقة واحد-لعدة بين العميل والحجز هي تصميم طبيعي لمنصة حجوزات لأن العميل قد يملك عدة حجوزات."
  - number: 46
    statement: "العلاقة عدة-لعدة تحتاج جدول ربط (Join Table) ولا تُحل بتكرار البيانات داخل صف واحد."
  - number: 47
    statement: "تصميم قاعدة البيانات يجب أن يحدد بوضوح من يملك الحقيقة (Source of Truth) لكل معلومة."
  - number: 48
    statement: "أي قرار تخزين يجب أن يراعي الاستعلامات الأساسية التي ستُنفذ يوميًا على الإنتاج."
  - number: 49
    statement: "أخطاء قاعدة البيانات تظهر عادةً عند زيادة الحجم أو عند إضافة ميزات جديدة تكشف التناقضات الكامنة."
  - number: 50
    statement: "إعادة الهيكلة المؤلمة لاحقًا غالبًا نتيجة تجاهل التطبيع والقيود والعلاقات منذ البداية."
  - number: 51
    statement: "سلامة البيانات (Data Integrity) تعني أن البيانات صحيحة ومتسقة ويمكن الاعتماد عليها عبر الزمن."
  - number: 52
    statement: "يجب حفظ سعر الخدمة داخل الطلب كـSnapshot لأن السعر في جدول الخدمات قد يتغير لاحقًا."
  - number: 53
    statement: "تغيير سعر الخدمة يجب ألا يغير فواتير الطلبات القديمة لأن الفاتورة تمثل واقعًا تاريخيًا وقت الشراء."
  - number: 54
    statement: "لقطة السعر (Price Snapshot) هي تثبيت السعر داخل سجل الطلب لحماية التقارير والمحاسبة من تغييرات المستقبل."
  - number: 55
    statement: "قد يلزم تثبيت معدل الضريبة أو العملة أو الخصم داخل الطلب لضمان صحة الحسابات التاريخية."
  - number: 56
    statement: "وجود Transaction ID فريد لكل عملية دفع ضروري لتتبع المدفوعات بدقة وربطها بالطلبات."
  - number: 57
    statement: "غياب معرفات المعاملات يجعل مطابقة الطلبات بالمدفوعات صعبة ويعقّد التحقيق في الفروقات."
  - number: 58
    statement: "جدول Payments مستقل ضروري لأنه يملك حقائق الدفع: المبلغ، الحالة، المزود، المعرفات، والأوقات."
  - number: 59
    statement: "سجل الدفع يجب أن يتضمن الحالة (Pending/Success/Failed) وتواريخ التحديث ومصدر الحدث لضمان التدقيق."
  - number: 60
    statement: "ميزة الإلغاء والاسترجاع تحتاج نموذج حالات واضح وسجل أحداث يضمن عدم تكرار الاسترجاع أو تضارب الحالة."
  - number: 61
    statement: "سجل تغييرات الحالة (Audit Log) يمكّن من معرفة “من فعل ماذا ومتى ولماذا” عند النزاعات."
  - number: 62
    statement: "فصل هوية العميل عن بيانات الحجز يمنع تكرار العميل ويضمن أن الحجز يشير دائمًا لعميل واحد صحيح."
  - number: 63
    statement: "القيود المرجعية تمنع حذف عميل له حجوزات دون معالجة أثر ذلك بشكل صحيح."
  - number: 64
    statement: "تصميم Refund يحتاج ربطًا واضحًا بين Refund والـPayment الأصلي ومعرفًا فريدًا لكل عملية استرجاع."
  - number: 65
    statement: "خاصية Idempotency مطلوبة في الدفع والاسترجاع لأن إعادة إرسال نفس الطلب يجب ألا تُكرر الأثر المالي."
  - number: 66
    statement: "حفظ سبب فشل الدفع أو الاسترجاع ضمن السجل يساعد على دعم العملاء والتحقيق الفني."
  - number: 67
    statement: "يجب التعامل مع الدفع كنطاق (Domain) مستقل وليس كحقل داخل الطلب فقط."
  - number: 68
    statement: "أي نظام مالي محترف يحتاج تتبعًا كاملاً للحالات وليس “حالة واحدة” داخل جدول عام."
  - number: 69
    statement: "الأثر التدقيقي (Audit Trail) هو سجل زمني للأحداث يضمن إمكانية المراجعة والامتثال والمحاسبة."
  - number: 70
    statement: "الدرس الأساسي هو أن التصميم الصحيح للكيانات والمعاملات يمنع فساد البيانات ويقلل كلفة التصحيح لاحقًا."
  - number: 71
    statement: "غياب الفهارس يجعل قاعدة البيانات تعتمد على مسح شامل للجداول مما يسبب بطئًا يتفاقم مع نمو البيانات."
  - number: 72
    statement: "الفهرس يشبه فهرس الكتاب لأنه يتيح الوصول السريع للصفوف دون قراءة كل الصفحات."
  - number: 73
    statement: "استخدام IDs رقمية يقلل حجم المفاتيح في الفهارس ويزيد سرعة المقارنة والبحث."
  - number: 74
    statement: "كلما زاد حجم المفتاح في الفهرس زادت كلفة التخزين والقراءة مما يضعف الأداء."
  - number: 75
    statement: "التوسع الرأسي يعني زيادة موارد الخادم نفسه، بينما التوسع الأفقي يعني زيادة عدد الخوادم وتوزيع الحمل."
  - number: 76
    statement: "يجب التفكير في التوسع مبكرًا لأن تغيير المعمارية بعد الإطلاق أصعب بكثير من بنائها صحيحة من البداية."
  - number: 77
    statement: "التخزين المؤقت (Caching) يقلل الحمل على قاعدة البيانات عندما تكون نفس البيانات تُقرأ بشكل متكرر."
  - number: 78
    statement: "موازن الحمل (Load Balancer) يوزع الطلبات على عدة خوادم لزيادة التوفر وتقليل زمن الاستجابة."
  - number: 79
    statement: "فصل القراءة عن الكتابة (Read/Write Separation) قد يحسن الأداء عند ارتفاع الطلبات القرائية بشكل كبير."
  - number: 80
    statement: "اختبارات التحمل (Load Testing) تكشف اختناقات الاستعلامات ونقاط الانهيار قبل أن يكتشفها المستخدمون."
  - number: 81
    statement: "عتاد قوي لا يعوض استعلامات سيئة أو نموذج بيانات خاطئ لأن الاختناق يكون منطقيًا لا عتاديًا فقط."
  - number: 82
    statement: "الأداء يعني سرعة الاستجابة الحالية، بينما قابلية التوسع تعني بقاء الأداء جيدًا عند زيادة الحمل."
  - number: 83
    statement: "إنشاء فهارس على أعمدة البحث والربط الأكثر استخدامًا يحسن الأداء بشكل كبير في الأنظمة عالية الحمل."
  - number: 84
    statement: "الإفراط في الفهارس قد يبطئ عمليات الإدراج والتحديث لأنه يفرض تحديث الفهرس مع كل تغيير."
  - number: 85
    statement: "المراقبة (Monitoring) يجب أن تقيس زمن الاستجابة، وعدد الاتصالات، واستهلاك الموارد، ونسب الأخطاء لاكتشاف التدهور مبكرًا."
  - number: 86
    statement: "إضافة ميزة جديدة لنظام بلا معمارية واضحة غالبًا تكشف تداخل المسؤوليات وتجبر الفريق على ترقيع خطر."
  - number: 87
    statement: "الدين التقني هو تكلفة مستقبلية تُدفع لاحقًا نتيجة حلول سريعة اليوم بدل تصميم صحيح."
  - number: 88
    statement: "الوصول لمرحلة “لا يمكن التطوير إلا بإعادة البناء” مؤشر على تراكم الدين التقني وضعف البنية."
  - number: 89
    statement: "فشل إضافة الإلغاء والاسترجاع يدل على غياب تصميم نطاق المدفوعات والعمليات منذ البداية."
  - number: 90
    statement: "المعمارية الجيدة تجعل الإضافة امتدادًا طبيعيًا عبر مكوّنات واضحة بدل تعديل عشوائي في كل مكان."
  - number: 91
    statement: "النظام الذي لا يُصمَّم للتغيير سيفشل عند أول طلب توسع أو تعديل كبير لأن التغيير سيكسر افتراضات قديمة."
  - number: 92
    statement: "المرونة تعني حدودًا واضحة وتجريدات مستقرة تسمح باستبدال التفاصيل دون تغيير منطق النظام."
  - number: 93
    statement: "قابلية الصيانة تُقاس بوضوح الكود، واختبارات جيدة، وفصل مسؤوليات، وتوثيق، ونموذج بيانات منطقي."
  - number: 94
    statement: "العشوائية في قاعدة البيانات تؤدي إلى استعلامات معقدة وأخطاء تكرار وتناقض تعرقل التطوير اليومي."
  - number: 95
    statement: "مبدأ “افهم ما تبنيه” يعني أن المطوّر يجب أن يفهم الكيان والعملية ومسار البيانات قبل كتابة أي سطر."
  - number: 96
    statement: "استخدام الذكاء الاصطناعي بنجاح يتطلب أن يكون التصميم والمعايير بيد الإنسان وأن تكون الأداة منفذة لا قائدة."
  - number: 97
    statement: "أي نظام موثوق يحتاج حدودًا واضحة بين المجال (Domain) والبنية التحتية (Infrastructure) لتقليل الارتباط."
  - number: 98
    statement: "اختيار بنية البيانات الصحيحة (IDs، فهارس، علاقات) أهم من “شكل الكود” لأنه يحدد مصير النظام تحت الضغط."
  - number: 99
    statement: "أهم حماية من الكوارث هي تصميم معماري ونموذج بيانات واختبارات وقياسات قبل أن يصل النظام لذروة الاستخدام."
  - number: 100
    statement: "الخلاصة أن النجاح في الأنظمة المعقدة يأتي من التخطيط والفهم والتحقق المستمر، لا من تجميع كود مولّد بالذكاء الاصطناعي دون رؤية."
