"""
المبادئ الصارمة للنظام على مستوى المشروع.

هذا الملف يمثل مصدر الحقيقة لمبادئ النظام الإلزامية
ويتيح الوصول البرمجي إليها بشكل موحد.
"""

from __future__ import annotations

from dataclasses import dataclass


@dataclass(frozen=True)
class SystemPrinciple:
    """تمثيل مبدأ واحد من مبادئ النظام الصارمة."""

    number: int
    statement: str


SYSTEM_PRINCIPLES: tuple[SystemPrinciple, ...] = (
    SystemPrinciple(
        1,
        "تعدد الأشكال في البرمجة كائنية التوجه يسمح بواجهة واحدة لاستدعاء عمليات متعددة حسب نوع الكائن وقت التنفيذ.",
    ),
    SystemPrinciple(2, "لا يمكن إنشاء كائن (Instance) مباشرةً من فئة مجردة (Abstract Class)."),
    SystemPrinciple(
        3,
        "الوراثة تتيح إعادة استخدام الشيفرة عبر إنشاء فئة جديدة تعتمد على خصائص وسلوك فئة موجودة.",
    ),
    SystemPrinciple(
        4,
        "التغليف (Encapsulation) يعني إخفاء التفاصيل الداخلية للكائن وإظهار واجهة محددة للتعامل معه.",
    ),
    SystemPrinciple(
        5, "الدالة النقية لا تقوم بتعديل متغيرات عامة أو إحداث تأثيرات جانبية على حالة خارجية."
    ),
    SystemPrinciple(
        6,
        "الدالة عالية الرتبة (Higher-Order Function) هي دالة تأخذ دوالًا كوسائط أو تُرجع دالة كنتيجة.",
    ),
    SystemPrinciple(
        7, "التقييم الكسول (Lazy Evaluation) يعني تأجيل حساب التعبير حتى الحاجة الفعلية لقيمته."
    ),
    SystemPrinciple(
        8,
        "عدم قابلية التغيير (Immutability) يساعد على تجنب الاعتماد على حالة متغيرة أثناء التنفيذ كما في البرمجة الوظيفية.",
    ),
    SystemPrinciple(
        9,
        "الكومة الثنائية (Binary Heap) مناسبة لتنفيذ صف ذي أولوية (Priority Queue) للحصول على أعلى أولوية بكفاءة.",
    ),
    SystemPrinciple(
        10,
        "بنية Trie (Prefix Tree) تخزن الكلمات حسب البادئات وتتيح البحث بكفاءة اعتمادًا على البادئة.",
    ),
    SystemPrinciple(11, "البحث بعرض (BFS) يستخدم صفًّا (Queue) لزيارة العقد مستوىً بمستوى."),
    SystemPrinciple(
        12,
        "جدول التجزئة (Hash Table) يخزن أزواج المفتاح/القيمة ويتيح بحثًا بمتوسط زمن قريب من ‎O(1)‎.",
    ),
    SystemPrinciple(
        13, "شجرة AVL هي شجرة بحث ثنائية ذاتية الاتزان تضمن عمليات ‎O(log n)‎ في أسوأ الأحوال."
    ),
    SystemPrinciple(
        14,
        "البرمجة الديناميكية (Dynamic Programming) تحل المشكلة عبر مشاكل فرعية وتخزن النتائج لتجنب إعادة الحساب.",
    ),
    SystemPrinciple(
        15,
        "خوارزمية Backtracking تبني الحل تدريجيًا وتتراجع عند اكتشاف أن المسار الحالي لن يؤدي إلى حل صحيح.",
    ),
    SystemPrinciple(16, "تعقيد البحث الثنائي (Binary Search) في قائمة مرتبة هو ‎O(log n)‎."),
    SystemPrinciple(
        17,
        "الخوارزميات الجشعة (Greedy) تتخذ قرارًا محليًا أفضل في كل خطوة على أمل الوصول لحل عالمي جيد.",
    ),
    SystemPrinciple(
        18,
        "حالة السباق (Race Condition) تحدث عندما تتنافس خيوط متعددة على مورد مشترك فتنتج نتائج غير متوقعة.",
    ),
    SystemPrinciple(
        19,
        "خيوط العملية الواحدة تشترك في نفس مساحة الذاكرة، بينما العمليات المنفصلة تملك ذاكرة معزولة.",
    ),
    SystemPrinciple(
        20,
        "القفل (Mutex) يمنع دخول أكثر من خيط إلى القسم الحرج في الوقت نفسه ويساعد على منع السباقات.",
    ),
    SystemPrinciple(21, "Singleton مثال على نمط تصميم من أنماط عصابة الأربعة (GoF)."),
    SystemPrinciple(22, "نمط Observer يقوم فيه الـSubject بإخطار الـObservers عند تغيّر حالته."),
    SystemPrinciple(
        23, "مبادئ SOLID الخمسة تهدف لتحسين قابلية الفهم والتطوير والصيانة في التصميم الكائني."
    ),
    SystemPrinciple(
        24,
        "نظرية CAP تشير إلى: الاتساق (Consistency) والتوافرية (Availability) وتحمل التقسيم (Partition Tolerance).",
    ),
    SystemPrinciple(25, "RPC يسمح باستدعاء إجراء على خادم بعيد كما لو كان استدعاءً محليًا."),
    SystemPrinciple(
        26,
        "طوابير الرسائل تفصل المكونات عبر تواصل غير متزامن وتمكّن اختلاف سرعات المنتج والمستهلك دون فقد البيانات.",
    ),
    SystemPrinciple(27, "Git نظام تحكم إصدارات موزع لتتبع وإدارة تاريخ الشيفرة المصدرية."),
    SystemPrinciple(
        28, "Docker يوفّر حاويات لتشغيل التطبيق مع تبعياته في بيئة معزولة تشارك نواة النظام المضيف."
    ),
    SystemPrinciple(29, "CI/CD تعني التكامل المستمر والتسليم المستمر (وأحيانًا النشر المستمر)."),
    SystemPrinciple(
        30, "Haskell تُعد لغة وظيفية خالصة (Purely Functional) بشكل افتراضي مع تقييم كسول."
    ),
    SystemPrinciple(
        31,
        "جعل Square يرث من Rectangle مع تغيير سلوك setWidth/setHeight يخرق مبدأ استبدال ليسكوف (LSP) لأنه يمنع الاستبدال الآمن.",
    ),
    SystemPrinciple(
        32, "مبدأ Open/Closed ينص على أن الكيانات البرمجية مفتوحة للإضافة ومغلقة للتعديل."
    ),
    SystemPrinciple(33, "Java لا تدعم الوراثة المتعددة للفئات مباشرةً لتجنب غموض مشكلة الماس."),
    SystemPrinciple(
        34,
        "مبدأ Dependency Inversion يفرض أن تعتمد الوحدات على التجريدات لا على التفاصيل، وأن تعتمد التفاصيل أيضًا على التجريدات.",
    ),
    SystemPrinciple(
        35,
        "الدالة عديمة الآثار الجانبية لا تغيّر حالة خارجية (مثل متغير عام أو ملف أو طباعة)، وهذا يجعلها أسهل للاختبار والتوازي والتنبؤ.",
    ),
    SystemPrinciple(
        36,
        "التقييم الكسول في Haskell يسمح بتعريف بنى بيانات لانهائية لأن القيم لا تُحسب إلا عند الحاجة.",
    ),
    SystemPrinciple(37, "العودية (Recursion) تُستخدم كثيرًا بدل الحلقات في البرمجة الوظيفية."),
    SystemPrinciple(
        38, "عقدة B-Tree قد تحتوي عدة مفاتيح وعدة أبناء، ما يقلل ارتفاع الشجرة مقارنةً بـBST."
    ),
    SystemPrinciple(39, "Trie هي الأنسب للبحث بحسب بادئة نصية كما في الإكمال التلقائي."),
    SystemPrinciple(40, "خوارزمية Dijkstra لا تعمل بشكل صحيح بوجود أوزان سالبة."),
    SystemPrinciple(
        41,
        "معالجة تصادمات Hash يمكن أن تتم عبر Chaining (قائمة/بنية لكل خانة) أو Open Addressing (البحث عن خانة بديلة وفق نمط).",
    ),
    SystemPrinciple(
        42,
        "البرمجة الديناميكية تتطلب Optimal Substructure وتداخل المشاكل الفرعية (Overlapping Subproblems).",
    ),
    SystemPrinciple(
        43,
        "الخوارزمية التقريبية لمسألة NP-صعبة قد لا تعطي الحل الأمثل لكنها تضمن حدًا/نسبة تقريب بالنسبة للأمثل.",
    ),
    SystemPrinciple(44, "الشيفرة ذات الحلقة المثلثية (j من 1 إلى i) تعقيدها الكلي من رتبة ‎O(n^2)‎."),
    SystemPrinciple(
        45,
        "QuickSort متوسطه ‎O(n log n)‎ وقد يصبح ‎O(n^2)‎ في أسوأ الحالات عند اختيار Pivot سيئ باستمرار.",
    ),
    SystemPrinciple(
        46,
        "Deadlock يحدث عندما تنتظر خيوط متعددة موارد يحتجزها بعضها البعض بشكل دائري فلا يتقدم أي خيط.",
    ),
    SystemPrinciple(47, "نموذج Actor يعتمد على تمرير الرسائل دون مشاركة حالة مباشرة بين المكونات."),
    SystemPrinciple(
        48,
        "مثال Race Condition: خيطان يزيدان counter في نفس الوقت فيضيع أحد التحديثين، ويُمنع ذلك بقفل Mutex أو عمليات ذرّية (Atomic).",
    ),
    SystemPrinciple(
        49,
        "Concurrency تعني تداخل المهام منطقيًا، وParallelism تعني تنفيذها فعليًا في نفس اللحظة على أكثر من نواة/معالج.",
    ),
    SystemPrinciple(
        50, "نمط Strategy يتيح تبديل خوارزميات قابلة للتبادل أثناء التشغيل دون تغيير الكود العميل."
    ),
    SystemPrinciple(
        51,
        "Reactive Programming تعتمد على تدفقات بيانات غير متزامنة تنشر التغيّرات تلقائيًا للمشتركين.",
    ),
    SystemPrinciple(52, "MVC يفصل Model عن View وعن Controller لتحسين التنظيم والصيانة."),
    SystemPrinciple(
        53, "Eventual Consistency تعني أن العقد ستتوافق في النهاية إذا توقفت التحديثات الجديدة."
    ),
    SystemPrinciple(
        54, "2PC يضمن ذرّية المعاملة الموزعة بحيث تُعتمد لدى الجميع أو تُلغى لدى الجميع وفق قرار منسّق."
    ),
    SystemPrinciple(
        55,
        "Strong Consistency تضمن رؤية أحدث كتابة فورًا، بينما Eventual Consistency قد تُظهر قراءات قديمة مؤقتًا ثم تتقارب لاحقًا.",
    ),
    SystemPrinciple(
        56,
        "زمن الشبكة (Latency) قد يؤثر بشدة على أداء وصحة الأنظمة الموزعة ويجب تصميم النظام مع افتراض وجود تأخير.",
    ),
    SystemPrinciple(
        57,
        "VM تشغّل نظام تشغيل كاملًا لكل آلة افتراضية، بينما Container يشغّل التطبيق وتبعياته مع مشاركة نواة المضيف وبكلفة أخف.",
    ),
    SystemPrinciple(
        58, "Kubernetes منصة شائعة لأتمتة نشر وإدارة حاويات Docker مع التوسع والتعافي الذاتي."
    ),
    SystemPrinciple(
        59,
        "CI يدمج ويختبر باستمرار، وCD يجهّز النشر باستمرار (أو ينشر تلقائيًا في حالة Continuous Deployment).",
    ),
    SystemPrinciple(
        60,
        "Profiling يقيس استهلاك الموارد لتحديد اختناقات الأداء مثل دوال تستهلك أكثر وقت CPU أو ذاكرة.",
    ),
    SystemPrinciple(
        61,
        "Design by Contract يحدد شروطًا مسبقة ولاحقة وثوابت صنف لضمان صحة السلوك ورفع موثوقية البرمجية.",
    ),
    SystemPrinciple(
        62,
        "مشكلة الماس في الوراثة المتعددة تنشأ عندما تتقاطع وراثتان من أصل مشترك فتظهر إشكالية أي نسخة من الأساس تُستخدم.",
    ),
    SystemPrinciple(
        63,
        "الشيفرة C++ ستطبع “Derived” لأن foo افتراضية وسيتم الربط ديناميكيًا حسب النوع الفعلي للكائن.",
    ),
    SystemPrinciple(
        64,
        "مبدأ Interface Segregation ينص على ألا يُجبر العملاء على الاعتماد على واجهات لا يحتاجونها.",
    ),
    SystemPrinciple(
        65,
        "مبدأ المسؤولية الواحدة (SRP) يعني أن لكل صنف سببًا واحدًا للتغيير مما يقلل التعقيد ويزيد قابلية الصيانة.",
    ),
    SystemPrinciple(
        66,
        "الموناد (Monad) هي بنية تربط عمليات في سياق (مثل Maybe أو IO) عبر bind/return لتسلسل العمليات دون معالجة السياق يدويًا كل مرة.",
    ),
    SystemPrinciple(
        67,
        "Eager Evaluation يحسب القيم فورًا وهو أسهل للتنبؤ بالأداء، بينما Lazy Evaluation يؤجل الحساب وقد يوفر عملًا لكنه قد يصعّب توقع الذاكرة والزمن.",
    ),
    SystemPrinciple(
        68,
        "الدوال النقية والبيانات غير القابلة للتغيير تسهّل التوازي لأن غياب الآثار الجانبية يقلل الحاجة للتزامن.",
    ),
    SystemPrinciple(
        69,
        "Tail Recursion Optimization يحول الاستدعاء الذاتي الأخير إلى شكل حلقي لتقليل استهلاك المكدس ومنع Stack Overflow.",
    ),
    SystemPrinciple(
        70,
        "التعبير take 5 (iterate (+1) 0) ينتج [0,1,2,3,4] لأن iterate تولد قائمة لانهائية وtake يأخذ أول خمسة عناصر فقط.",
    ),
    SystemPrinciple(
        71,
        "Trie مناسبة للإكمال التلقائي لأنها تجعل زمن البحث مرتبطًا بطول البادئة وتسمح باستعراض كل الكلمات تحت عقدة البادئة.",
    ),
    SystemPrinciple(
        72,
        "Hash Table متوسطه ‎O(1)‎ لكن أسوأه قد يصل ‎O(n)‎، بينما الشجرة المتوازنة تضمن ‎O(log n)‎ في أسوأ الحالات.",
    ),
    SystemPrinciple(
        73, "Trie قد تستهلك ذاكرة أكبر عندما تكون مجموعة الكلمات كبيرة والتشارك في البادئات قليل."
    ),
    SystemPrinciple(
        74,
        "B-Tree ذات تفرع عالٍ تقلل عمق الشجرة وعدد عمليات I/O على القرص لذا تناسب قواعد البيانات والتخزين الخارجي.",
    ),
    SystemPrinciple(
        75,
        "أفضل نهج لاستخراج أكبر 10 قيم من مليون عنصر هو الاحتفاظ بـMin-Heap بحجم 10 أثناء المرور لتحقيق ‎O(n log 10)‎.",
    ),
    SystemPrinciple(
        76,
        "NP-Complete تعني أن المسألة في NP وكل مسائل NP يمكن اختزالها إليها، ولا يُعرف حل متعدد الحدود لها عمومًا.",
    ),
    SystemPrinciple(
        77,
        "Memoization أسلوب Top-Down مع كاش لنتائج الاستدعاءات العودية، وTabulation أسلوب Bottom-Up يبني جدولًا من الحالات الأصغر للأكبر.",
    ),
    SystemPrinciple(78, "إذا تضاعف n وزاد الزمن إلى 8× فالتعقيد المرجح هو ‎O(n^3)‎."),
    SystemPrinciple(
        79,
        "مثال خوارزمية تقريبية: Vertex Cover بخوارزمية تقريب 2-Approx التي تختار طرفي ضلع غير مغطى وتكرر حتى تغطية كل الأضلاع.",
    ),
    SystemPrinciple(
        80, "Bellman-Ford تصلح لإيجاد أقصر مسارات مع أوزان سالبة طالما لا توجد دورات سالبة."
    ),
    SystemPrinciple(
        81,
        "Semaphore يدير عددًا من “التصاريح” لمورد محدود، بينما Mutex قفل حصري لمورد واحد عادةً؛ مثلًا Semaphore بقيمة 3 يحد عدد الاتصالات المتزامنة إلى 3.",
    ),
    SystemPrinciple(
        82,
        "Data Parallelism يعني نفس العملية على أجزاء بيانات مختلفة (مثل جمع أجزاء مصفوفة)، وTask Parallelism يعني مهام مختلفة بالتوازي (مثل معالجة لون الصورة وتطبيق فلتر في آن واحد).",
    ),
    SystemPrinciple(
        83, "قانون أمدال يحدد حدًا أعلى للتسريع بسبب الجزء المتسلسل الذي لا يمكن موازنته بالكامل."
    ),
    SystemPrinciple(
        84,
        "GIL في CPython يمنع تنفيذ بايت كود بايثون في أكثر من خيط في نفس الوقت داخل نفس العملية، ما يحد من توازي المهام الحسابية.",
    ),
    SystemPrinciple(
        85,
        "Go تستخدم goroutines خفيفة وChannels للتواصل بأسلوب مستوحى من CSP عبر تمرير الرسائل بدل مشاركة الذاكرة.",
    ),
    SystemPrinciple(
        86,
        "Clean Architecture تعزل منطق الأعمال في الداخل وتفرض قاعدة الاعتماد بأن تتجه الاعتماديات نحو الداخل فقط لا نحو التفاصيل الخارجية.",
    ),
    SystemPrinciple(
        87,
        "Backpressure آلية لضبط تدفق البيانات عندما يكون المستهلك أبطأ من المنتج لتجنب الانهيار أو نفاد الذاكرة.",
    ),
    SystemPrinciple(
        88,
        "Dependency Injection يحقق DIP عمليًا بتمرير التبعيات من الخارج بدل إنشائها داخليًا، مما يقلل الاقتران ويسهّل الاختبار.",
    ),
    SystemPrinciple(
        89,
        "نمط Visitor يسمح بإضافة عمليات جديدة على كائنات متعددة دون تعديل تعريف هذه الكائنات عبر “زائر” ينفذ العمليات عليها.",
    ),
    SystemPrinciple(
        90,
        "Loose Coupling يعني اعتمادًا ضعيفًا بين المكونات عبر واجهات وتجريدات بحيث يمكن تغيير جزء دون كسر بقية النظام.",
    ),
    SystemPrinciple(
        91,
        "ACID يركز على الذرية والاتساق والعزل والدوام، بينما BASE يركز على التوافر الأساسي والحالة المرنة والاتساق النهائي في بعض NoSQL.",
    ),
    SystemPrinciple(
        92,
        "2PC يعمل بمرحلة Prepare للتصويت ثم مرحلة Commit/Abort لضمان أن الجميع يلتزم أو الجميع يتراجع.",
    ),
    SystemPrinciple(
        93,
        "نظام مصرفي غالبًا يفضل CP (اتساق + تحمل تقسيم) حتى لو ضحّى بالتوافرية أثناء الانقسام لتجنب أخطاء مالية.",
    ),
    SystemPrinciple(
        94,
        "Message Queue تفصل الخدمات وتزيد المرونة والتوسع عبر تخزين الرسائل ومعالجتها لاحقًا وتمكين زيادة عدد المستهلكين عند الذروة.",
    ),
    SystemPrinciple(
        95,
        "Idempotence مهمة لأنها تسمح بإعادة إرسال الطلبات أو تكرار التنفيذ عند الفشل دون مضاعفة الأثر النهائي.",
    ),
    SystemPrinciple(
        96,
        "git merge يدمج التاريخ مع Merge Commit ويحافظ على التشعب، بينما git rebase يعيد كتابة التاريخ ليصبح خطيًا ويُفضّل على الفروع الخاصة قبل مشاركتها.",
    ),
    SystemPrinciple(
        97,
        "Kubernetes يوفّر Self-healing بإعادة تشغيل الحاويات أو إعادة جدولة Pods عند الفشل للحفاظ على توفر الخدمة.",
    ),
    SystemPrinciple(
        98,
        "Blue-Green Deployment يستخدم بيئتين متطابقتين ويحوّل المرور من القديمة للجديدة دفعة واحدة لتقليل التوقف وتسهيل الرجوع السريع.",
    ),
    SystemPrinciple(
        99,
        "Distributed Tracing يربط الطلب عبر الخدمات باستخدام Trace ID وSpans ليُظهر أين حدث التأخير أو الخطأ داخل سلسلة الخدمات.",
    ),
    SystemPrinciple(
        100,
        "Logging وMonitoring وDistributed Tracing تشكل معًا أعمدة Observability لفهم الحالة الداخلية للنظام وتشخيص الأعطال بسرعة.",
    ),
)


ARCHITECTURE_SYSTEM_PRINCIPLES: tuple[SystemPrinciple, ...] = (
    SystemPrinciple(
        1,
        "لا يمكن بناء نظام حقيقي يتحمل آلاف المستخدمين ويحافظ على بياناتهم دون فهمٍ معماري واضح يسبق كتابة الكود.",
    ),
    SystemPrinciple(
        2,
        "التصميم المعماري هو خارطة قرار تحدد مكوّنات النظام وحدودها وتدفق البيانات بينها قبل التنفيذ.",
    ),
    SystemPrinciple(
        3,
        "القفز مباشرةً إلى البرمجة دون توثيق المتطلبات يؤدي غالبًا إلى إعادة البناء عند أول تغيير كبير.",
    ),
    SystemPrinciple(
        4,
        "تدفق البيانات (Data Flow) يجب أن يُعرَّف مبكرًا لأنّه يحدد أين تُنشأ البيانات وأين تُعالج وأين تُخزَّن.",
    ),
    SystemPrinciple(
        5,
        "المتطلبات غير الوظيفية مثل الأداء والأمن والتوسع ليست تفاصيل ثانوية بل تُحدد شكل المعمارية من البداية.",
    ),
    SystemPrinciple(
        6,
        "أي ميزة جديدة ستكشف عيوب التصميم إذا لم تكن حدود المسؤوليات بين المكوّنات واضحة.",
    ),
    SystemPrinciple(
        7,
        "التخطيط المعماري الجيد يقلل أثر التغيير (Change Impact) ويمنع انهيار أجزاء غير مرتبطة عند إضافة ميزة.",
    ),
    SystemPrinciple(
        8,
        "التصميم عالي المستوى يحدد الخدمات والمكوّنات والواجهات، بينما التصميم منخفض المستوى يحدد تفاصيل التنفيذ داخل كل مكوّن.",
    ),
    SystemPrinciple(
        9,
        "وجود وثائق تصميم مختصرة لكن دقيقة يمنع “المعرفة القبلية” ويُسهل دخول أعضاء جدد للفريق.",
    ),
    SystemPrinciple(
        10,
        "إعادة بناء النظام من الصفر غالبًا علامة على أن نموذج البيانات والحدود المعمارية صُممت بعشوائية في البداية.",
    ),
    SystemPrinciple(
        11,
        "أدوات الذكاء الاصطناعي تزيد السرعة لكنها لا تعوّض فهم المطوّر لمتطلبات النظام وقيوده.",
    ),
    SystemPrinciple(
        12,
        "الكود الذي يولّده الذكاء الاصطناعي قد يبدو صحيحًا محليًا لكنه قد يكون خاطئًا ضمن سياق النظام ككل.",
    ),
    SystemPrinciple(
        13,
        "الذكاء الاصطناعي لا يضمن الالتزام بمعايير الأمان والحوكمة والامتثال ما لم يحددها مهندس يفهمها.",
    ),
    SystemPrinciple(
        14,
        "بناء نظام قابل للتوسع يحتاج قرارات معمارية، والذكاء الاصطناعي لا يتحمل مسؤولية هذه القرارات عنك.",
    ),
    SystemPrinciple(
        15,
        "الاعتماد على الـPrompts دون مراجعة هندسية ينتج “نظامًا متشابكًا” يصعب صيانته واختباره.",
    ),
    SystemPrinciple(
        16,
        "دور الذكاء الاصطناعي الأفضل هو مساعدتك في التنفيذ، بينما دورك أنت هو التصميم والتحقق والقرار.",
    ),
    SystemPrinciple(
        17,
        "أي مخرجات ذكاء اصطناعي يجب أن تمر بمراجعة كود واختبارات وتدقيق أمني قبل اعتمادها.",
    ),
    SystemPrinciple(
        18,
        "الذكاء الاصطناعي لا يعرف أولويات العمل ولا مخاطر التغيير في الإنتاج مثل فريق المنتج والهندسة.",
    ),
    SystemPrinciple(
        19,
        "استخدام الذكاء الاصطناعي بوعي يعني تزويده بسياق معماري واضح وقيود صارمة ثم التحقق من النتائج.",
    ),
    SystemPrinciple(
        20,
        "لا يوجد “Prompt” يعوض غياب نموذج بيانات صحيح أو غياب تصميم لمعالجة الدفع والاسترجاع.",
    ),
    SystemPrinciple(
        21,
        "تصميم النظام هو تحويل المتطلبات إلى مكوّنات وواجهات وقرارات تخزين واتصال قابلة للتنفيذ.",
    ),
    SystemPrinciple(
        22,
        "جمع المتطلبات يتضمن تحديد الكيانات الأساسية والأحداث والسيناريوهات والحالات الاستثنائية قبل اختيار التقنية.",
    ),
    SystemPrinciple(
        23,
        "الأداء والأمن وقابلية التوسع والموثوقية تُعد متطلبات غير وظيفية يجب تحديدها صراحة.",
    ),
    SystemPrinciple(
        24,
        "التصميم المعماري يحدد حدود الخدمات أو الطبقات ويمنع تضخم “خدمة كل شيء” أو “جدول كل شيء”.",
    ),
    SystemPrinciple(
        25,
        "مخطط المكوّنات يوضح من يستدعي من، ومخطط تدفق البيانات يوضح ماذا ينتقل وأين يتم حفظه.",
    ),
    SystemPrinciple(
        26,
        "توثيق واجهات الـAPI مبكرًا يمنع اختلاف التوقعات بين الواجهة الأمامية والخلفية والخدمات الأخرى.",
    ),
    SystemPrinciple(
        27,
        "التفكير المستقبلي يعني تصميمًا يسمح بإضافة ميزات دون كسر البيانات التاريخية أو تغيير جذري في التخزين.",
    ),
    SystemPrinciple(
        28,
        "نموذج البيانات هو العمود الفقري للنظام لأن معظم الميزات تعتمد على صحة العلاقات بين الكيانات.",
    ),
    SystemPrinciple(
        29,
        "عدم وجود توثيق معماري يجعل النظام “قائمًا على الذاكرة البشرية” وهي مخاطرة تشغيلية كبيرة.",
    ),
    SystemPrinciple(
        30,
        "نجاح النظام لا يقاس بسرعة الإطلاق فقط بل بقدرة الفريق على التطوير بثبات بعد الإطلاق.",
    ),
    SystemPrinciple(
        31,
        "التطبيع (Normalization) يعني فصل البيانات إلى جداول تمثل كيانات مستقلة لتقليل التكرار ومنع التناقض.",
    ),
    SystemPrinciple(
        32,
        "قاعدة “جدول واحد لكل كيان” تجعل البيانات أوضح وتقلل أخطاء التعديل غير المقصود.",
    ),
    SystemPrinciple(
        33,
        "تخزين العميل والخدمة والسعر والحالة في جدول واحد يؤدي إلى تكرار البيانات وتضاربها مع الزمن.",
    ),
    SystemPrinciple(
        34,
        "الدمج العشوائي للحقول في جدول واحد يسبب صعوبة إضافة ميزات مثل الاسترجاع والمدفوعات والتقارير.",
    ),
    SystemPrinciple(
        35,
        "فصل الجداول يسمح بفرض قيود تكامل مرجعي تمنع وجود حجوزات بلا عميل أو مدفوعات بلا طلب.",
    ),
    SystemPrinciple(
        36,
        "المفتاح الأساسي (Primary Key) معرف فريد لكل صف ويجب أن يكون ثابتًا وغير قابل للتغيير.",
    ),
    SystemPrinciple(
        37,
        "المفتاح الأجنبي (Foreign Key) يربط صفًا بصف آخر ويحمي من الروابط الوهمية والأخطاء المنطقية.",
    ),
    SystemPrinciple(
        38,
        "وجود جدول Customers مستقل يمنع تكرار العميل ويجعل جميع حجوزاته قابلة للتجميع بسهولة.",
    ),
    SystemPrinciple(
        39,
        "تكرار بيانات العميل في حجوزات متعددة يخلق عملاء مكررين ويؤدي لضياع الحجوزات عند التحديث أو الدمج.",
    ),
    SystemPrinciple(
        40,
        "التكرار (Redundancy) يرفع احتمال التناقض لأن تعديل نسخة واحدة لا يضمن تعديل النسخ الأخرى.",
    ),
    SystemPrinciple(
        41,
        "القيود الفريدة (Unique) تمنع تسجيل نفس البريد أو رقم الهوية أكثر من مرة عندما يكون ذلك مطلوبًا.",
    ),
    SystemPrinciple(
        42,
        "استخدام نص طويل كمفتاح ربط أبطأ وأثقل على الفهارس من استخدام معرف رقمي قصير.",
    ),
    SystemPrinciple(
        43,
        "الاعتماد على النصوص بدل IDs يزيد حجم الفهرس ويبطئ المقارنات ويزيد فرص الأخطاء الإملائية والتباينات.",
    ),
    SystemPrinciple(
        44,
        "مخطط ERD قبل التنفيذ يساعد على اكتشاف نواقص الكيانات والعلاقات مثل غياب جدول المدفوعات.",
    ),
    SystemPrinciple(
        45,
        "العلاقة واحد-لعدة بين العميل والحجز هي تصميم طبيعي لمنصة حجوزات لأن العميل قد يملك عدة حجوزات.",
    ),
    SystemPrinciple(
        46,
        "العلاقة عدة-لعدة تحتاج جدول ربط (Join Table) ولا تُحل بتكرار البيانات داخل صف واحد.",
    ),
    SystemPrinciple(
        47,
        "تصميم قاعدة البيانات يجب أن يحدد بوضوح من يملك الحقيقة (Source of Truth) لكل معلومة.",
    ),
    SystemPrinciple(
        48,
        "أي قرار تخزين يجب أن يراعي الاستعلامات الأساسية التي ستُنفذ يوميًا على الإنتاج.",
    ),
    SystemPrinciple(
        49,
        "أخطاء قاعدة البيانات تظهر عادةً عند زيادة الحجم أو عند إضافة ميزات جديدة تكشف التناقضات الكامنة.",
    ),
    SystemPrinciple(
        50,
        "إعادة الهيكلة المؤلمة لاحقًا غالبًا نتيجة تجاهل التطبيع والقيود والعلاقات منذ البداية.",
    ),
    SystemPrinciple(
        51,
        "سلامة البيانات (Data Integrity) تعني أن البيانات صحيحة ومتسقة ويمكن الاعتماد عليها عبر الزمن.",
    ),
    SystemPrinciple(
        52,
        "يجب حفظ سعر الخدمة داخل الطلب كـSnapshot لأن السعر في جدول الخدمات قد يتغير لاحقًا.",
    ),
    SystemPrinciple(
        53,
        "تغيير سعر الخدمة يجب ألا يغير فواتير الطلبات القديمة لأن الفاتورة تمثل واقعًا تاريخيًا وقت الشراء.",
    ),
    SystemPrinciple(
        54,
        "لقطة السعر (Price Snapshot) هي تثبيت السعر داخل سجل الطلب لحماية التقارير والمحاسبة من تغييرات المستقبل.",
    ),
    SystemPrinciple(
        55,
        "قد يلزم تثبيت معدل الضريبة أو العملة أو الخصم داخل الطلب لضمان صحة الحسابات التاريخية.",
    ),
    SystemPrinciple(
        56,
        "وجود Transaction ID فريد لكل عملية دفع ضروري لتتبع المدفوعات بدقة وربطها بالطلبات.",
    ),
    SystemPrinciple(
        57,
        "غياب معرفات المعاملات يجعل مطابقة الطلبات بالمدفوعات صعبة ويعقّد التحقيق في الفروقات.",
    ),
    SystemPrinciple(
        58,
        "جدول Payments مستقل ضروري لأنه يملك حقائق الدفع: المبلغ، الحالة، المزود، المعرفات، والأوقات.",
    ),
    SystemPrinciple(
        59,
        "سجل الدفع يجب أن يتضمن الحالة (Pending/Success/Failed) وتواريخ التحديث ومصدر الحدث لضمان التدقيق.",
    ),
    SystemPrinciple(
        60,
        "ميزة الإلغاء والاسترجاع تحتاج نموذج حالات واضح وسجل أحداث يضمن عدم تكرار الاسترجاع أو تضارب الحالة.",
    ),
    SystemPrinciple(
        61,
        "سجل تغييرات الحالة (Audit Log) يمكّن من معرفة “من فعل ماذا ومتى ولماذا” عند النزاعات.",
    ),
    SystemPrinciple(
        62,
        "فصل هوية العميل عن بيانات الحجز يمنع تكرار العميل ويضمن أن الحجز يشير دائمًا لعميل واحد صحيح.",
    ),
    SystemPrinciple(
        63,
        "القيود المرجعية تمنع حذف عميل له حجوزات دون معالجة أثر ذلك بشكل صحيح.",
    ),
    SystemPrinciple(
        64,
        "تصميم Refund يحتاج ربطًا واضحًا بين Refund والـPayment الأصلي ومعرفًا فريدًا لكل عملية استرجاع.",
    ),
    SystemPrinciple(
        65,
        "خاصية Idempotency مطلوبة في الدفع والاسترجاع لأن إعادة إرسال نفس الطلب يجب ألا تُكرر الأثر المالي.",
    ),
    SystemPrinciple(
        66,
        "حفظ سبب فشل الدفع أو الاسترجاع ضمن السجل يساعد على دعم العملاء والتحقيق الفني.",
    ),
    SystemPrinciple(
        67,
        "يجب التعامل مع الدفع كنطاق (Domain) مستقل وليس كحقل داخل الطلب فقط.",
    ),
    SystemPrinciple(
        68,
        "أي نظام مالي محترف يحتاج تتبعًا كاملاً للحالات وليس “حالة واحدة” داخل جدول عام.",
    ),
    SystemPrinciple(
        69,
        "الأثر التدقيقي (Audit Trail) هو سجل زمني للأحداث يضمن إمكانية المراجعة والامتثال والمحاسبة.",
    ),
    SystemPrinciple(
        70,
        "الدرس الأساسي هو أن التصميم الصحيح للكيانات والمعاملات يمنع فساد البيانات ويقلل كلفة التصحيح لاحقًا.",
    ),
    SystemPrinciple(
        71,
        "غياب الفهارس يجعل قاعدة البيانات تعتمد على مسح شامل للجداول مما يسبب بطئًا يتفاقم مع نمو البيانات.",
    ),
    SystemPrinciple(
        72,
        "الفهرس يشبه فهرس الكتاب لأنه يتيح الوصول السريع للصفوف دون قراءة كل الصفحات.",
    ),
    SystemPrinciple(
        73,
        "استخدام IDs رقمية يقلل حجم المفاتيح في الفهارس ويزيد سرعة المقارنة والبحث.",
    ),
    SystemPrinciple(
        74,
        "كلما زاد حجم المفتاح في الفهرس زادت كلفة التخزين والقراءة مما يضعف الأداء.",
    ),
    SystemPrinciple(
        75,
        "التوسع الرأسي يعني زيادة موارد الخادم نفسه، بينما التوسع الأفقي يعني زيادة عدد الخوادم وتوزيع الحمل.",
    ),
    SystemPrinciple(
        76,
        "يجب التفكير في التوسع مبكرًا لأن تغيير المعمارية بعد الإطلاق أصعب بكثير من بنائها صحيحة من البداية.",
    ),
    SystemPrinciple(
        77,
        "التخزين المؤقت (Caching) يقلل الحمل على قاعدة البيانات عندما تكون نفس البيانات تُقرأ بشكل متكرر.",
    ),
    SystemPrinciple(
        78,
        "موازن الحمل (Load Balancer) يوزع الطلبات على عدة خوادم لزيادة التوفر وتقليل زمن الاستجابة.",
    ),
    SystemPrinciple(
        79,
        "فصل القراءة عن الكتابة (Read/Write Separation) قد يحسن الأداء عند ارتفاع الطلبات القرائية بشكل كبير.",
    ),
    SystemPrinciple(
        80,
        "اختبارات التحمل (Load Testing) تكشف اختناقات الاستعلامات ونقاط الانهيار قبل أن يكتشفها المستخدمون.",
    ),
    SystemPrinciple(
        81,
        "عتاد قوي لا يعوض استعلامات سيئة أو نموذج بيانات خاطئ لأن الاختناق يكون منطقيًا لا عتاديًا فقط.",
    ),
    SystemPrinciple(
        82,
        "الأداء يعني سرعة الاستجابة الحالية، بينما قابلية التوسع تعني بقاء الأداء جيدًا عند زيادة الحمل.",
    ),
    SystemPrinciple(
        83,
        "إنشاء فهارس على أعمدة البحث والربط الأكثر استخدامًا يحسن الأداء بشكل كبير في الأنظمة عالية الحمل.",
    ),
    SystemPrinciple(
        84,
        "الإفراط في الفهارس قد يبطئ عمليات الإدراج والتحديث لأنه يفرض تحديث الفهرس مع كل تغيير.",
    ),
    SystemPrinciple(
        85,
        "المراقبة (Monitoring) يجب أن تقيس زمن الاستجابة، وعدد الاتصالات، واستهلاك الموارد، ونسب الأخطاء لاكتشاف التدهور مبكرًا.",
    ),
    SystemPrinciple(
        86,
        "إضافة ميزة جديدة لنظام بلا معمارية واضحة غالبًا تكشف تداخل المسؤوليات وتجبر الفريق على ترقيع خطر.",
    ),
    SystemPrinciple(
        87,
        "الدين التقني هو تكلفة مستقبلية تُدفع لاحقًا نتيجة حلول سريعة اليوم بدل تصميم صحيح.",
    ),
    SystemPrinciple(
        88,
        "الوصول لمرحلة “لا يمكن التطوير إلا بإعادة البناء” مؤشر على تراكم الدين التقني وضعف البنية.",
    ),
    SystemPrinciple(
        89,
        "فشل إضافة الإلغاء والاسترجاع يدل على غياب تصميم نطاق المدفوعات والعمليات منذ البداية.",
    ),
    SystemPrinciple(
        90,
        "المعمارية الجيدة تجعل الإضافة امتدادًا طبيعيًا عبر مكوّنات واضحة بدل تعديل عشوائي في كل مكان.",
    ),
    SystemPrinciple(
        91,
        "النظام الذي لا يُصمَّم للتغيير سيفشل عند أول طلب توسع أو تعديل كبير لأن التغيير سيكسر افتراضات قديمة.",
    ),
    SystemPrinciple(
        92,
        "المرونة تعني حدودًا واضحة وتجريدات مستقرة تسمح باستبدال التفاصيل دون تغيير منطق النظام.",
    ),
    SystemPrinciple(
        93,
        "قابلية الصيانة تُقاس بوضوح الكود، واختبارات جيدة، وفصل مسؤوليات، وتوثيق، ونموذج بيانات منطقي.",
    ),
    SystemPrinciple(
        94,
        "العشوائية في قاعدة البيانات تؤدي إلى استعلامات معقدة وأخطاء تكرار وتناقض تعرقل التطوير اليومي.",
    ),
    SystemPrinciple(
        95,
        "مبدأ “افهم ما تبنيه” يعني أن المطوّر يجب أن يفهم الكيان والعملية ومسار البيانات قبل كتابة أي سطر.",
    ),
    SystemPrinciple(
        96,
        "استخدام الذكاء الاصطناعي بنجاح يتطلب أن يكون التصميم والمعايير بيد الإنسان وأن تكون الأداة منفذة لا قائدة.",
    ),
    SystemPrinciple(
        97,
        "أي نظام موثوق يحتاج حدودًا واضحة بين المجال (Domain) والبنية التحتية (Infrastructure) لتقليل الارتباط.",
    ),
    SystemPrinciple(
        98,
        "اختيار بنية البيانات الصحيحة (IDs، فهارس، علاقات) أهم من “شكل الكود” لأنه يحدد مصير النظام تحت الضغط.",
    ),
    SystemPrinciple(
        99,
        "أهم حماية من الكوارث هي تصميم معماري ونموذج بيانات واختبارات وقياسات قبل أن يصل النظام لذروة الاستخدام.",
    ),
    SystemPrinciple(
        100,
        "الخلاصة أن النجاح في الأنظمة المعقدة يأتي من التخطيط والفهم والتحقق المستمر، لا من تجميع كود مولّد بالذكاء الاصطناعي دون رؤية.",
    ),
)


def _validate_principles(
    *,
    principles: tuple[SystemPrinciple, ...],
    label: str,
) -> None:
    """
    التحقق من سلامة قائمة مبادئ محددة.

    Args:
        principles: قائمة المبادئ المطلوب التحقق منها.
        label: اسم القائمة لرسائل الخطأ.

    Raises:
        ValueError: عند اكتشاف خلل في القائمة.
    """
    errors: list[str] = []
    expected_numbers = set(range(1, 101))
    numbers = [item.number for item in principles]
    statements = [item.statement for item in principles]

    if len(principles) != 100:
        errors.append(f"عدد مبادئ {label} يجب أن يكون 100 مبدأ بالضبط.")

    if set(numbers) != expected_numbers:
        errors.append(f"ترقيم مبادئ {label} يجب أن يغطي النطاق الكامل من 1 إلى 100 دون تكرار.")

    if any(not statement.strip() for statement in statements):
        errors.append(f"يجب أن يحتوي كل مبدأ في {label} على نص غير فارغ.")

    if errors:
        message = "؛ ".join(errors)
        raise ValueError(message)


def get_system_principles() -> tuple[SystemPrinciple, ...]:
    """الحصول على جميع مبادئ النظام الصارمة بشكل ثابت."""

    return SYSTEM_PRINCIPLES


def format_system_principles(
    *,
    header: str = "المبادئ الصارمة للنظام",
    bullet: str = "-",
    include_header: bool = True,
) -> str:
    """
    تنسيق مبادئ النظام الصارمة كنص جاهز للإدراج في السياقات المختلفة.

    Args:
        header: عنوان القسم.
        bullet: رمز التعداد النقطي.
        include_header: تحديد تضمين العنوان من عدمه.

    Returns:
        str: نص منسق للمبادئ.
    """
    prefix = f"{bullet} " if bullet else ""
    lines = [
        f"{prefix}{principle.number}. {principle.statement}" for principle in SYSTEM_PRINCIPLES
    ]
    body = "\n".join(lines)
    if include_header:
        return f"{header}\n{body}"
    return body


def get_architecture_system_principles() -> tuple[SystemPrinciple, ...]:
    """الحصول على مبادئ المعمارية وحوكمة البيانات الأساسية."""

    return ARCHITECTURE_SYSTEM_PRINCIPLES


def format_architecture_system_principles(
    *,
    header: str = "مبادئ المعمارية وحوكمة البيانات الأساسية",
    bullet: str = "-",
    include_header: bool = True,
) -> str:
    """
    تنسيق مبادئ المعمارية الأساسية كنص جاهز للإدراج في السياقات المختلفة.

    Args:
        header: عنوان القسم.
        bullet: رمز التعداد النقطي.
        include_header: تحديد تضمين العنوان من عدمه.

    Returns:
        str: نص منسق للمبادئ.
    """
    prefix = f"{bullet} " if bullet else ""
    lines = [
        f"{prefix}{principle.number}. {principle.statement}"
        for principle in ARCHITECTURE_SYSTEM_PRINCIPLES
    ]
    body = "\n".join(lines)
    if include_header:
        return f"{header}\n{body}"
    return body


def validate_system_principles(
    principles: tuple[SystemPrinciple, ...] | None = None,
) -> None:
    """
    التحقق من سلامة مبادئ النظام الصارمة.

    يضمن هذا التحقق تطبيق المبادئ فعلياً عبر التأكد من:
    - اكتمال القائمة (100 مبدأ).
    - الترتيب والترقيم الصحيح (1..100 بدون تكرار).
    - وجود نص غير فارغ لكل مبدأ.

    Args:
        principles: قائمة المبادئ المطلوب التحقق منها. افتراضياً تستخدم القائمة الرسمية.

    Raises:
        ValueError: عند اكتشاف خلل في القائمة.
    """
    items = principles or SYSTEM_PRINCIPLES
    _validate_principles(principles=items, label="النظام")


def validate_architecture_system_principles(
    principles: tuple[SystemPrinciple, ...] | None = None,
) -> None:
    """
    التحقق من سلامة مبادئ المعمارية وحوكمة البيانات الأساسية.

    Args:
        principles: قائمة المبادئ المطلوب التحقق منها. افتراضياً تستخدم القائمة الرسمية.

    Raises:
        ValueError: عند اكتشاف خلل في القائمة.
    """
    items = principles or ARCHITECTURE_SYSTEM_PRINCIPLES
    _validate_principles(principles=items, label="المعمارية وحوكمة البيانات")
