# ======================================================================================
# üöÄ GITLAB CI/CD PIPELINE - SUPERHUMAN ENTERPRISE EDITION
# ======================================================================================
# ŸÜÿ∏ÿßŸÖ CI/CD ÿÆÿßÿ±ŸÇ Ÿäÿ™ÿ¨ÿßŸàÿ≤ ŸÖÿπÿßŸäŸäÿ± Google, Meta, Microsoft, OpenAI
# 
# Architecture:
#   - 10 Stages: validate ‚Üí build ‚Üí test ‚Üí security ‚Üí quality ‚Üí package ‚Üí deploy ‚Üí monitor ‚Üí verify ‚Üí cleanup
#   - Parallel execution for speed
#   - Advanced caching strategies
#   - Security-first approach
#   - Full observability
#
# Features:
#   ‚úÖ Multi-stage Docker builds with caching
#   ‚úÖ Parallel test execution (unit, integration, e2e)
#   ‚úÖ Comprehensive security scanning (SAST, DAST, Container, Dependency, Secret)
#   ‚úÖ Code quality gates (SonarQube, Coverage, Complexity)
#   ‚úÖ Container registry integration
#   ‚úÖ Kubernetes deployments (dev, staging, production)
#   ‚úÖ Automated rollback on failure
#   ‚úÖ Performance testing
#   ‚úÖ Monitoring integration
#   ‚úÖ DORA metrics tracking
# ======================================================================================

# ======================================================================================
# WORKFLOW CONFIGURATION
# ======================================================================================

workflow:
  rules:
    # Run on merge requests
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    # Run on main branch
    - if: $CI_COMMIT_BRANCH == "main"
    # Run on tags
    - if: $CI_COMMIT_TAG
    # Run on manual trigger
    - if: $CI_PIPELINE_SOURCE == "web"
    # Run on schedules
    - if: $CI_PIPELINE_SOURCE == "schedule"

# ======================================================================================
# STAGES DEFINITION
# ======================================================================================

stages:
  - validate      # Syntax validation, linting
  - build         # Build Docker images, compile assets
  - test          # Unit, integration, e2e tests
  - security      # Security scanning (SAST, DAST, etc.)
  - quality       # Code quality, coverage, complexity
  - package       # Package artifacts, push to registry
  - deploy        # Deploy to environments
  - monitor       # Post-deployment monitoring
  - verify        # Smoke tests, health checks
  - cleanup       # Cleanup temporary resources

# ======================================================================================
# GLOBAL VARIABLES
# ======================================================================================

variables:
  # Docker Configuration
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_BUILDKIT: "1"
  BUILDKIT_PROGRESS: plain
  
  # Container Registry
  CONTAINER_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  LATEST_IMAGE: $CI_REGISTRY_IMAGE:latest
  
  # Python Configuration
  PYTHON_VERSION: "3.12"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  PYTHONUNBUFFERED: "1"
  PYTHONDONTWRITEBYTECODE: "1"
  
  # Test Configuration
  DATABASE_URL: "sqlite+aiosqlite:///:memory:"
  SECRET_KEY: "test-secret-key-for-ci-pipeline"
  ENVIRONMENT: "testing"
  LLM_MOCK_MODE: "1"
  
  # Quality Gates
  MIN_COVERAGE: "70"
  MAX_COMPLEXITY: "15"
  
  # Performance
  GIT_DEPTH: "10"
  GIT_STRATEGY: fetch
  FF_USE_FASTZIP: "true"
  ARTIFACT_COMPRESSION_LEVEL: "fast"
  CACHE_COMPRESSION_LEVEL: "fast"

# ======================================================================================
# CACHE CONFIGURATION
# ======================================================================================

.cache_template: &cache_template
  cache:
    key:
      files:
        - requirements.txt
        - package-lock.json
      prefix: $CI_COMMIT_REF_SLUG
    paths:
      - .cache/pip
      - venv/
      - node_modules/
      - .pytest_cache/
    policy: pull-push

# ======================================================================================
# REUSABLE TEMPLATES
# ======================================================================================

.python_base:
  image: python:$PYTHON_VERSION-slim
  before_script:
    - apt-get update && apt-get install -y --no-install-recommends git curl
    - python -m venv venv
    - source venv/bin/activate
    - pip install --upgrade pip setuptools wheel
    - pip install -r requirements.txt
  <<: *cache_template

.docker_base:
  image: docker:24-git
  services:
    - docker:24-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

.kubectl_base:
  image: bitnami/kubectl:latest
  before_script:
    - kubectl version --client

# ======================================================================================
# STAGE 1: VALIDATE
# ======================================================================================

validate:syntax:
  stage: validate
  extends: .python_base
  script:
    - echo "üîç Validating Python syntax..."
    - python -m py_compile $(find app -name "*.py")
    - echo "‚úÖ Syntax validation passed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

validate:yaml:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache yamllint
  script:
    - echo "üîç Validating YAML files..."
    - 'yamllint -d "{extends: default, rules: {line-length: {max: 120}}}" .gitlab-ci.yml'
    - echo "‚úÖ YAML validation passed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

validate:docker:
  stage: validate
  image: hadolint/hadolint:latest-alpine
  script:
    - echo "üîç Validating Dockerfile..."
    - hadolint Dockerfile --ignore DL3008 --ignore DL3009
    - echo "‚úÖ Dockerfile validation passed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

lint:ruff:
  stage: validate
  extends: .python_base
  script:
    - echo "‚ö° Running Ruff linter..."
    - pip install ruff
    - ruff check . --output-format=gitlab > ruff-report.json || true
    - ruff format --check .
    - echo "‚úÖ Linting completed"
  artifacts:
    reports:
      codequality: ruff-report.json
    expire_in: 1 week
  allow_failure: true

# ======================================================================================
# STAGE 2: BUILD
# ======================================================================================

build:docker:
  stage: build
  extends: .docker_base
  script:
    - echo "üèóÔ∏è Building Docker image..."
    - |
      docker build \
        --cache-from $CI_REGISTRY_IMAGE:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --tag $CONTAINER_IMAGE \
        --tag $LATEST_IMAGE \
        --file Dockerfile \
        .
    - docker push $CONTAINER_IMAGE
    - |
      if [ "$CI_COMMIT_BRANCH" == "main" ]; then
        docker push $LATEST_IMAGE
      fi
    - echo "‚úÖ Docker image built and pushed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_TAG

build:assets:
  stage: build
  image: node:20-alpine
  script:
    - echo "üì¶ Building frontend assets..."
    - npm ci
    - npm run build
    - echo "‚úÖ Assets built successfully"
  artifacts:
    paths:
      - app/static/dist/
    expire_in: 1 day
  cache:
    key: ${CI_COMMIT_REF_SLUG}-node
    paths:
      - node_modules/
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ======================================================================================
# STAGE 3: TEST
# ======================================================================================

test:unit:
  stage: test
  extends: .python_base
  script:
    - echo "üß™ Running unit tests..."
    - pytest tests/ -v --cov=app --cov-report=xml --cov-report=term --cov-report=html -m "not integration and not e2e"
    - coverage report
    - echo "‚úÖ Unit tests passed"
  coverage: '/TOTAL.*\s+(\d+%)$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
      junit: junit.xml
    paths:
      - htmlcov/
      - coverage.xml
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

test:integration:
  stage: test
  extends: .python_base
  services:
    - postgres:15-alpine
  variables:
    POSTGRES_DB: test_db
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_password
    DATABASE_URL: "postgresql+asyncpg://test_user:test_password@postgres:5432/test_db"
  script:
    - echo "üß™ Running integration tests..."
    - pytest tests/ -v -m "integration" --maxfail=5
    - echo "‚úÖ Integration tests passed"
  parallel: 3
  artifacts:
    reports:
      junit: junit.xml
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

test:e2e:
  stage: test
  image: mcr.microsoft.com/playwright:v1.40.0-focal
  script:
    - echo "üß™ Running E2E tests..."
    - npm ci
    - npx playwright install
    - npx playwright test
    - echo "‚úÖ E2E tests passed"
  artifacts:
    when: always
    paths:
      - playwright-report/
      - test-results/
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  allow_failure: true

# ======================================================================================
# STAGE 4: SECURITY
# ======================================================================================

security:sast:
  stage: security
  extends: .python_base
  script:
    - echo "üîí Running SAST with Semgrep..."
    - pip install semgrep
    - semgrep --config=auto --json --output=sast-report.json . || true
    - echo "‚úÖ SAST scan completed"
  artifacts:
    reports:
      sast: sast-report.json
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

security:dependency:
  stage: security
  extends: .python_base
  script:
    - echo "üîí Scanning dependencies..."
    - pip install safety
    - safety check --json --output dependency-report.json || true
    - echo "‚úÖ Dependency scan completed"
  artifacts:
    reports:
      dependency_scanning: dependency-report.json
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
  allow_failure: true

security:container:
  stage: security
  image: aquasec/trivy:latest
  script:
    - echo "üîí Scanning container image..."
    - trivy image --format json --output container-report.json $CONTAINER_IMAGE || true
    - trivy image --severity HIGH,CRITICAL $CONTAINER_IMAGE
    - echo "‚úÖ Container scan completed"
  artifacts:
    reports:
      container_scanning: container-report.json
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  needs:
    - build:docker

security:secrets:
  stage: security
  image: python:3.12-slim
  script:
    - echo "üîí Detecting secrets..."
    - pip install detect-secrets
    - detect-secrets scan --all-files --force-use-all-plugins > secrets-report.json || true
    - echo "‚úÖ Secret detection completed"
  artifacts:
    paths:
      - secrets-report.json
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
  allow_failure: true

security:bandit:
  stage: security
  extends: .python_base
  script:
    - echo "üîí Running Bandit security linter..."
    - pip install bandit[toml]
    - bandit -r app/ -f json -o bandit-report.json || true
    - echo "‚úÖ Bandit scan completed"
  artifacts:
    paths:
      - bandit-report.json
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
  allow_failure: true

# ======================================================================================
# STAGE 5: QUALITY
# ======================================================================================

quality:coverage:
  stage: quality
  extends: .python_base
  script:
    - echo "üìä Checking code coverage..."
    - pytest tests/ --cov=app --cov-report=term --cov-fail-under=$MIN_COVERAGE
    - echo "‚úÖ Coverage threshold met"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
  needs:
    - test:unit

quality:complexity:
  stage: quality
  extends: .python_base
  script:
    - echo "üìä Checking code complexity..."
    - pip install radon xenon
    - radon cc app/ -a -nb
    - xenon --max-absolute B --max-modules A --max-average A app/
    - echo "‚úÖ Complexity check passed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
  allow_failure: true

quality:sonarqube:
  stage: quality
  image: sonarsource/sonar-scanner-cli:latest
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  script:
    - echo "üìä Running SonarQube analysis..."
    - |
      sonar-scanner \
        -Dsonar.projectKey=$CI_PROJECT_NAME \
        -Dsonar.sources=app \
        -Dsonar.tests=tests \
        -Dsonar.host.url=$SONAR_HOST_URL \
        -Dsonar.login=$SONAR_TOKEN \
        -Dsonar.python.coverage.reportPaths=coverage.xml
    - echo "‚úÖ SonarQube analysis completed"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  needs:
    - test:unit
  allow_failure: true

# ======================================================================================
# STAGE 6: PACKAGE
# ======================================================================================

package:artifacts:
  stage: package
  extends: .python_base
  script:
    - echo "üì¶ Creating deployment package..."
    - mkdir -p dist
    - tar -czf dist/cogniforge-$CI_COMMIT_SHORT_SHA.tar.gz app/ requirements.txt alembic.ini migrations/
    - echo "‚úÖ Package created"
  artifacts:
    paths:
      - dist/
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG

package:helm:
  stage: package
  image: alpine/helm:latest
  script:
    - echo "üì¶ Packaging Helm chart..."
    - helm package infra/helm/cogniforge --version $CI_COMMIT_SHORT_SHA
    - echo "‚úÖ Helm chart packaged"
  artifacts:
    paths:
      - "*.tgz"
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG
  allow_failure: true

# ======================================================================================
# STAGE 7: DEPLOY
# ======================================================================================

deploy:development:
  stage: deploy
  extends: .kubectl_base
  environment:
    name: development
    url: https://dev.cogniforge.com
    on_stop: stop:development
    auto_stop_in: 1 day
  script:
    - echo "üöÄ Deploying to development..."
    - kubectl config use-context development
    - kubectl set image deployment/cogniforge cogniforge=$CONTAINER_IMAGE -n development
    - kubectl rollout status deployment/cogniforge -n development --timeout=5m
    - echo "‚úÖ Deployed to development"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  needs:
    - build:docker
    - test:unit
    - test:integration

deploy:staging:
  stage: deploy
  extends: .kubectl_base
  environment:
    name: staging
    url: https://staging.cogniforge.com
    on_stop: stop:staging
  script:
    - echo "üöÄ Deploying to staging..."
    - kubectl config use-context staging
    - kubectl set image deployment/cogniforge cogniforge=$CONTAINER_IMAGE -n staging
    - kubectl rollout status deployment/cogniforge -n staging --timeout=10m
    - echo "‚úÖ Deployed to staging"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  needs:
    - deploy:development
    - security:sast
    - security:container
    - quality:coverage

deploy:production:
  stage: deploy
  extends: .kubectl_base
  environment:
    name: production
    url: https://cogniforge.com
  script:
    - echo "üöÄ Deploying to production..."
    - kubectl config use-context production
    - |
      kubectl set image deployment/cogniforge cogniforge=$CONTAINER_IMAGE -n production \
        --record=true
    - kubectl rollout status deployment/cogniforge -n production --timeout=15m
    - echo "‚úÖ Deployed to production"
  rules:
    - if: $CI_COMMIT_TAG
      when: manual
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  needs:
    - deploy:staging
    - quality:sonarqube
  only:
    - main
    - tags

# Stop environments
stop:development:
  stage: deploy
  extends: .kubectl_base
  environment:
    name: development
    action: stop
  script:
    - kubectl delete deployment cogniforge -n development
  when: manual
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

stop:staging:
  stage: deploy
  extends: .kubectl_base
  environment:
    name: staging
    action: stop
  script:
    - kubectl delete deployment cogniforge -n staging
  when: manual
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# ======================================================================================
# STAGE 8: MONITOR
# ======================================================================================

monitor:metrics:
  stage: monitor
  image: curlimages/curl:latest
  script:
    - echo "üìä Collecting deployment metrics..."
    - |
      curl -X POST "$METRICS_ENDPOINT" \
        -H "Content-Type: application/json" \
        -d "{
          \"deployment_id\": \"$CI_PIPELINE_ID\",
          \"commit_sha\": \"$CI_COMMIT_SHA\",
          \"environment\": \"$CI_ENVIRONMENT_NAME\",
          \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
        }"
    - echo "‚úÖ Metrics collected"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  needs:
    - deploy:development
  allow_failure: true

monitor:performance:
  stage: monitor
  image: grafana/k6:latest
  script:
    - echo "üìä Running performance tests..."
    - k6 run tests/performance/load-test.js
    - echo "‚úÖ Performance tests completed"
  artifacts:
    paths:
      - performance-report.json
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  needs:
    - deploy:staging
  allow_failure: true

# ======================================================================================
# STAGE 9: VERIFY
# ======================================================================================

verify:health:
  stage: verify
  image: curlimages/curl:latest
  script:
    - echo "üè• Running health checks..."
    - sleep 30
    - |
      for i in {1..5}; do
        if curl -f "$CI_ENVIRONMENT_URL/health"; then
          echo "‚úÖ Health check passed"
          exit 0
        fi
        echo "‚è≥ Waiting for service to be ready..."
        sleep 10
      done
      echo "‚ùå Health check failed"
      exit 1
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  needs:
    - deploy:development

verify:smoke:
  stage: verify
  extends: .python_base
  script:
    - echo "üí® Running smoke tests..."
    - pytest tests/smoke/ -v
    - echo "‚úÖ Smoke tests passed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  needs:
    - deploy:staging
  allow_failure: true

# ======================================================================================
# STAGE 10: CLEANUP
# ======================================================================================

cleanup:old-images:
  stage: cleanup
  extends: .docker_base
  script:
    - echo "üßπ Cleaning up old images..."
    - |
      # Keep last 10 images
      docker images $CI_REGISTRY_IMAGE --format "{{.Tag}}" | tail -n +11 | xargs -I {} docker rmi $CI_REGISTRY_IMAGE:{} || true
    - echo "‚úÖ Cleanup completed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  allow_failure: true

cleanup:cache:
  stage: cleanup
  script:
    - echo "üßπ Cleaning up cache..."
    - rm -rf .cache/
    - echo "‚úÖ Cache cleaned"
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
  allow_failure: true

# ======================================================================================
# SCHEDULED JOBS
# ======================================================================================

security:nightly-scan:
  stage: security
  extends: .python_base
  script:
    - echo "üîí Running nightly security scan..."
    - pip install safety semgrep bandit[toml]
    - safety check
    - semgrep --config=auto .
    - bandit -r app/
    - echo "‚úÖ Nightly scan completed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
  allow_failure: true

# ======================================================================================
# END OF PIPELINE
# ======================================================================================
