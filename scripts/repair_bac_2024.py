import asyncio
import json
import os
import ssl

from sqlalchemy import text
from sqlalchemy.ext.asyncio import create_async_engine

# User provided DB URL
DATABASE_URL = os.environ.get("DATABASE_URL")


async def repair():
    print("ğŸ”§ Starting Repair for BAC 2024 Probability Exercise...")

    if not DATABASE_URL:
        print("âŒ DATABASE_URL environment variable is not set.")
        return

    # Ensure async driver
    url = (
        DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://")
        .replace("?sslmode=require", "")
        .replace("&sslmode=require", "")
    )

    # SSL Context for asyncpg
    ssl_ctx = ssl.create_default_context()
    ssl_ctx.check_hostname = False
    ssl_ctx.verify_mode = ssl.CERT_NONE

    engine = create_async_engine(
        url,
        echo=False,
        connect_args={
            "statement_cache_size": 0,
            "prepared_statement_cache_size": 0,
            "ssl": ssl_ctx,
        },
    )

    try:
        async with engine.connect() as conn:
            # 1. Verify Content ID exists
            content_id = "bac-2024-exp-math-s1-ex1"
            print(f"ğŸ” Verifying Content Item: {content_id}")
            result = await conn.execute(
                text("SELECT id FROM content_items WHERE id = :id"), {"id": content_id}
            )
            if not result.fetchone():
                print(f"âŒ Content Item {content_id} not found! Cannot link.")
                return

            # 2. Find Target Nodes
            # We target nodes with the specific name generated by the ingestion script
            target_name = "ØªÙ…Ø±ÙŠÙ† Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„Ø§Øª Ø¨ÙƒØ§Ù„ÙˆØ±ÙŠØ§ 2024 Ø´Ø¹Ø¨Ø© Ø¹Ù„ÙˆÙ… ØªØ¬Ø±ÙŠØ¨ÙŠØ©"
            print(f"ğŸ” Finding Knowledge Nodes: '{target_name}'")

            stmt = text("SELECT id, metadata FROM knowledge_nodes WHERE name = :name")
            result = await conn.execute(stmt, {"name": target_name})
            nodes = result.fetchall()

            if not nodes:
                print("âŒ No knowledge nodes found to repair.")
                return

            print(f"âœ… Found {len(nodes)} nodes. Updating metadata...")

            # 3. Update Metadata
            for node in nodes:
                # Parse existing metadata
                meta = node.metadata
                if isinstance(meta, str):
                    meta = json.loads(meta)
                elif meta is None:
                    meta = {}

                # Update fields
                meta["content_id"] = content_id
                meta["year"] = 2024
                meta["subject"] = "mathematics"
                meta["branch"] = "experimental_sciences"
                meta["level"] = "3AS"
                meta["type"] = "exercise"

                # Convert back to JSON string or dict depending on DB driver handling
                # asyncpg/sqlalchemy with JSONB usually takes dict, but let's be safe and check if it's text column or jsonb
                # schema says metadata is JSONB. So passing dict is correct.

                print(f"   - Updating Node {node.id}...")

                # Update query
                update_stmt = text("""
                    UPDATE knowledge_nodes
                    SET metadata = :meta
                    WHERE id = :id
                """)

                # Ensure meta is dumped to string if necessary, but usually SQLAlchemy handles JSONB with dicts.
                # However, schema validator said `metadata JSONB`.
                # Let's pass the dict.
                await conn.execute(update_stmt, {"meta": json.dumps(meta), "id": node.id})

            # 4. Update Content Item Title & Search Text (Robustness Layer)
            print("ğŸ’ª Strengthening Content Item & Search Index...")

            # Update Title
            new_title = "Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø§Ù„Ø£ÙˆÙ„ (04 Ù†Ù‚Ø§Ø·) - Ø¨ÙƒØ§Ù„ÙˆØ±ÙŠØ§ 2024 - Ø¹Ù„ÙˆÙ… ØªØ¬Ø±ÙŠØ¨ÙŠØ©"
            await conn.execute(
                text("""
                UPDATE content_items
                SET title = :title
                WHERE id = :id
            """),
                {"title": new_title, "id": content_id},
            )

            # Update Search Text (Append Keywords)
            # We verify first if keywords exist to avoid duplicate appends
            search_row = await conn.execute(
                text("SELECT plain_text FROM content_search WHERE content_id = :id"),
                {"id": content_id},
            )
            row = search_row.fetchone()
            if row:
                current_text = row[0]
                keywords_to_add = "\n\n[Keywords: BAC 2024, Baccalaureate 2024, Experimental Sciences, Mathematics, 2024, Ø¨ÙƒØ§Ù„ÙˆØ±ÙŠØ§ 2024]"

                if "BAC 2024" not in current_text:
                    new_text = current_text + keywords_to_add
                    await conn.execute(
                        text("""
                        UPDATE content_search
                        SET plain_text = :text
                        WHERE content_id = :id
                    """),
                        {"text": new_text, "id": content_id},
                    )
                    print("   - Added search keywords to content_search.")
                else:
                    print("   - Search keywords already present.")

            await conn.commit()
            print("âœ¨ Repair Complete! Metadata & Search Index updated.")

    except Exception as e:
        print(f"âŒ Error during repair: {e}")
    finally:
        await engine.dispose()


if __name__ == "__main__":
    asyncio.run(repair())
