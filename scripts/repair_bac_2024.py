import asyncio
import json
from sqlalchemy import text
from sqlalchemy.ext.asyncio import create_async_engine

import os

import ssl

# User provided DB URL
DATABASE_URL = os.environ.get("DATABASE_URL")

async def repair():
    print(f"ğŸ”§ Starting Repair for BAC 2024 Probability Exercise...")

    if not DATABASE_URL:
        print("âŒ DATABASE_URL environment variable is not set.")
        return

    # Ensure async driver
    url = DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://")

    # SSL Context for asyncpg
    ssl_ctx = ssl.create_default_context()
    ssl_ctx.check_hostname = False
    ssl_ctx.verify_mode = ssl.CERT_NONE

    engine = create_async_engine(
        url,
        echo=False,
        connect_args={
            "statement_cache_size": 0,
            "prepared_statement_cache_size": 0,
            "ssl": ssl_ctx
        }
    )

    try:
        async with engine.connect() as conn:
            # 1. Verify Content ID exists
            content_id = 'bac-2024-exp-math-s1-ex1'
            print(f"ğŸ” Verifying Content Item: {content_id}")
            result = await conn.execute(text("SELECT id FROM content_items WHERE id = :id"), {"id": content_id})
            if not result.fetchone():
                print(f"âŒ Content Item {content_id} not found! Cannot link.")
                return

            # 2. Find Target Nodes
            # We target nodes with the specific name generated by the ingestion script
            target_name = "ØªÙ…Ø±ÙŠÙ† Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„Ø§Øª Ø¨ÙƒØ§Ù„ÙˆØ±ÙŠØ§ 2024 Ø´Ø¹Ø¨Ø© Ø¹Ù„ÙˆÙ… ØªØ¬Ø±ÙŠØ¨ÙŠØ©"
            print(f"ğŸ” Finding Knowledge Nodes: '{target_name}'")

            stmt = text("SELECT id, metadata FROM knowledge_nodes WHERE name = :name")
            result = await conn.execute(stmt, {"name": target_name})
            nodes = result.fetchall()

            if not nodes:
                print("âŒ No knowledge nodes found to repair.")
                return

            print(f"âœ… Found {len(nodes)} nodes. Updating metadata...")

            # 3. Update Metadata
            for node in nodes:
                # Parse existing metadata
                meta = node.metadata
                if isinstance(meta, str):
                    meta = json.loads(meta)
                elif meta is None:
                    meta = {}

                # Update fields
                meta["content_id"] = content_id
                meta["year"] = 2024
                meta["subject"] = "mathematics"
                meta["branch"] = "experimental_sciences"
                meta["level"] = "3AS"
                meta["type"] = "exercise"

                # Convert back to JSON string or dict depending on DB driver handling
                # asyncpg/sqlalchemy with JSONB usually takes dict, but let's be safe and check if it's text column or jsonb
                # schema says metadata is JSONB. So passing dict is correct.

                print(f"   - Updating Node {node.id}...")

                # Update query
                update_stmt = text("""
                    UPDATE knowledge_nodes
                    SET metadata = :meta
                    WHERE id = :id
                """)

                # Ensure meta is dumped to string if necessary, but usually SQLAlchemy handles JSONB with dicts.
                # However, schema validator said `metadata JSONB`.
                # Let's pass the dict.
                await conn.execute(update_stmt, {"meta": json.dumps(meta), "id": node.id})

            await conn.commit()
            print("âœ¨ Repair Complete! Metadata updated.")

    except Exception as e:
        print(f"âŒ Error during repair: {e}")
    finally:
        await engine.dispose()

if __name__ == "__main__":
    asyncio.run(repair())
