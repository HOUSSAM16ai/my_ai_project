# التشخيص الجذري الدقيق لكارثة "القفز بين المراحل" وتعطل البحث

## الملخص التنفيذي

بعد فحص مسار الأحداث من محرك Overmind حتى واجهة الهاتف، الكارثة ليست خطأً واحدًا، بل **4 كسور بنيوية** تتفاعل معًا:

1. **تدفق المراحل الحقيقي لا يحتوي مرحلة بحث مستقلة أصلًا** (المحرك يرسل: إثراء سياق → تخطيط → تصميم → تنفيذ → مراجعة)، بينما الواجهة تعرض "البحث" كمرحلة رسمية.
2. **الواجهة تختزل مرحلتين مختلفتين داخل نفس المرحلة (`plan`)** لأن `DESIGN` يُعاد تعيينه إلى `plan`، فيظهر للمستخدم أن التقدم غير منطقي أو يقفز.
3. **حالة المهمة النهائية تُحفظ كـ `SUCCESS` حتى عند وجود فشل تشغيلي جزئي** (مثل فشل أداة البحث)، فيظهر تناقض: "تم الإيقاف بسبب خطأ" + "الحالة النهائية success".
4. **أداة البحث الحديثة تُرجع عنصر `type: error` داخل قائمة نتائج بدل رفع فشل صريح**؛ فيمر الفشل عبر السلسلة كأنه "نتيجة" وليس خطأ نظامي.

النتيجة: المستخدم يرى واجهة غير متسقة زمنيًا، ومؤشرات تقدم مضللة، ورسائل نجاح رغم انهيار جزء البحث فعليًا.

---

## التشريح الجذري (Root Cause Tree)

## الجذر (A): عدم التطابق بين مراحل المحرك ومراحل الواجهة

### الدليل
- الواجهة تُعرّف المراحل: `contextualize`, `plan`, `research`, `execute`, `review`.
- محرك LangGraph لا يرسل مرحلة بحث مستقلة ضمن المسار القياسي؛ يرسل: `CONTEXT_ENRICHMENT`, `PLANNING`, `DESIGN`, `EXECUTION`, `REFLECTION`, `RE-PLANNING`.

### الأثر
- مؤشر "البحث" غالبًا يبقى خامدًا أو غير مفهوم.
- المستخدم يشعر أن النظام "تخطى" البحث وانتقل مباشرة لمرحلة متقدمة.

---

## الجذر (B): تدمير المعنى الزمني بسبب Mapping خاطئ

### الدليل
- في `useAgentTimeline` تم تعيين:
  - `PLANNING -> plan`
  - `DESIGN -> plan`
  - `RE-PLANNING -> plan`
- أي أن ثلاث حالات معرفية مختلفة تكتب على نفس المفتاح `plan`.

### الأثر
- الواجهة لا تستطيع تمييز: "وضع خطة أولية" vs "تصميم" vs "إعادة تخطيط".
- يظهر للمستخدم أن المرحلة نفسها تتكرر/تقفز، رغم أن المحرك فعليًا انتقل بين عقد مختلفة.

---

## الجذر (C): تناقض الحالة النهائية (Success Masking)

### الدليل
- `complete_mission()` يضع الحالة دائمًا `MissionStatus.SUCCESS` عند وصول نهاية الحلقة، دون فحص دقيق لحالة التنفيذ الداخلية (`partial_failure` أو `failed` داخل نتائج المهام).
- وكيل التنفيذ نفسه يقدر الحالة الإجمالية `partial_failure` عندما تفشل بعض المهام، لكن هذا لا يمنع إغلاق المهمة على أنها `SUCCESS`.

### الأثر
- تظهر للمستخدم رسائل متعارضة: تحذير من خطأ + علم success.
- فريق التشغيل يفقد القدرة على الثقة في `status` كمرجع تشخيصي.

---

## الجذر (D): كسر عقدة البحث الصريح (Error-as-Data Anti-Pattern)

### الدليل
- `search_content()` عند الفشل يُرجع قائمة فيها كائن `type: "error"` بدل رفع استثناء أو إعادة حالة فشل معيارية.
- مسار التنفيذ يعتبر النتيجة "عودة طبيعية" من الأداة، ما يضعف تصعيد الفشل إلى حالة مهمة فاشلة.

### الأثر
- فشل البحث يُستهلك كنص داخل النتيجة بدل إطلاق "فشل مرحلة البحث".
- ينهار منطق "fail fast" ويظهر النظام كأنه "اشتغل" بينما لم ينجز البحث.

---

## لماذا يظهر السلوك على الهاتف كـ"قفز" تحديدًا؟

1. المستخدم يرى نصوص أحداث طويلة ومتلاحقة من عدة وكلاء.
2. نفس خانة `plan` تُكتب أكثر من مرة لثلاث مراحل مختلفة.
3. عند الفشل الجزئي، النهاية ما تزال `SUCCESS` فتنهار قصة التنفيذ منطقيًا أمام المستخدم.

هذا ليس Lag بصري فقط؛ إنه **تشوه في نموذج الحالة المعروض**.

---

## خلاصة قاطعة

السبب الحقيقي ليس "بطء" أو "مشكلة واجهة بسيطة"؛ السبب هو:

- **عدم اتساق عقد المراحل عبر الطبقات** (Engine ≠ Timeline UI).
- **تجميع مراحل معرفية مختلفة تحت مفتاح واحد**.
- **سياسة إنهاء متساهلة تسوّي الفشل الجزئي بالنجاح**.
- **إخفاء فشل البحث داخل بيانات بدل اعتباره حدث فشل تشغيلي**.

طالما هذه الأربعة موجودة معًا، ستستمر نفس الكارثة (قفز/تشويش/بحث يبدو معطّل/نهاية مضللة) حتى لو عدّلنا الشكل البصري فقط.
