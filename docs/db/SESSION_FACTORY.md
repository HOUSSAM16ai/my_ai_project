# Enterprise-Grade SQLAlchemy Session Factory

## 1. Purpose & Goal

This document describes the `session_factory` module located at `app/db/session_factory.py`.

The primary goal of this module is to provide a **robust, configurable, and independent SQLAlchemy session factory**. This is a foundational step in the strategic migration from a tightly-coupled Flask application to a more modern, decoupled architecture using FastAPI/ASGI.

**Key characteristics:**
- **Independence:** It has zero dependencies on the Flask application context (`current_app`, `g`, etc.). This allows it to be used in any part of the application, including FastAPI endpoints, WebSocket handlers, CLI commands, and standalone scripts.
- **Safety:** It is an *additive* component. It does not modify or interfere with the existing Flask-SQLAlchemy setup (`db.session`). Both systems can coexist, ensuring the current application continues to function without any changes.
- **Testability:** Its independence makes services that use it easier to test in isolation, without needing to construct a full Flask application context.
- **Reversibility:** The entire feature is self-contained. It can be removed by reverting a single commit if necessary.

## 2. How to Use

The factory provides two primary functions for obtaining a database session.

### A. `create_session()`

This function returns a single, non-managed SQLAlchemy session. It's best suited for scenarios where you need direct control over the session's lifecycle, such as:
- Standalone scripts
- Custom CLI commands
- Complex, multi-stage background tasks

**Example:**
```python
from app.db.session_factory import create_session

def run_standalone_query():
    print("Creating a new session...")
    db_session = create_session()
    try:
        # Your database logic here
        user_count = db_session.execute("SELECT count(*) FROM users").scalar()
        print(f"Found {user_count} users.")
    finally:
        print("Closing session.")
        db_session.close()
```

### B. `get_session_generator()`

This function is a Python generator designed specifically for dependency injection in frameworks like FastAPI. It yields a session and ensures it's automatically closed after the request is handled, even if errors occur.

**Example (for future FastAPI integration):**
```python
# In a future FastAPI endpoint file (e.g., app/api/routes/users.py)

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from app.db.session_factory import get_session_generator

router = APIRouter()

@router.get("/users/count")
def get_user_count(db: Session = Depends(get_session_generator)):
    """
    Gets the total number of users from the database.
    The `db` session is provided by the dependency injection system.
    """
    user_count = db.execute("SELECT count(*) FROM users").scalar()
    return {"user_count": user_count}
```

## 3. Configuration

The session factory is configured primarily through environment variables:

- `DATABASE_URL` (Required): The full SQLAlchemy connection string (e.g., `postgresql://user:password@host:port/dbname`). The factory will raise a `ValueError` if this is not set.
- `DB_ECHO` (Optional): If set to `true`, `1`, or `t`, all SQL statements generated by the engine will be printed to the console. Defaults to `false`.

The connection pool is pre-configured with safe defaults (`pool_size=5`, `max_overflow=10`, `pool_pre_ping=True`), suitable for a production environment.

## 4. Rollback and Safety

This component is completely parallel to the existing `Flask-SQLAlchemy` integration. It does not replace or modify it. Therefore, it can be safely removed by reverting the commit that added it without affecting the existing application's functionality.
