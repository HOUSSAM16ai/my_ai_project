# مبادئ التخزين المؤقت (الكاش) — الالتزام الحرفي

هذه الوثيقة تُحوِّل المبادئ التالية إلى مرجع رسمي داخل المشروع. كل بند هنا يُعد قاعدة تشغيلية ومعرفية يجب أن تنعكس على التصميم والتنفيذ والتشغيل والمراقبة.

## 1. تعريفات أساسية
1. **ذاكرة التخزين المؤقت (الكاش)** تقنية تحفظ البيانات أو نتائج العمليات الأكثر تكرارًا في وسيط سريع لتقليل زمن الاستجابة وتخفيف الحمل على المصدر الأساسي.
2. الكاش هو حفظ البيانات المستخدمة بشكل متكرر في موقع تخزين سريع بهدف تحسين الأداء.
3. قاعدة البيانات العلائقية ليست نوعًا من أنواع ذاكرة التخزين المؤقت.

## 2. أنواع الكاش وأماكنه
4. كلٌّ من Redis وMemcached يمكن استخدامه كنظام كاش موزّع.
5. الكاش داخل الذاكرة (In-Memory Cache) يخزّن البيانات في RAM لتسريع الوصول إليها.
6. الكاش الموزّع (Distributed Cache) يعني توزيع البيانات المخبأة عبر عدة خوادم/عُقد.
7. الـCDN يخزّن المحتوى الثابت مؤقتًا على خوادم موزعة جغرافيًا لتقديمه من أقرب نقطة للمستخدم وتقليل زمن الاستجابة.
8. المتصفح يخزّن ملفات مثل الصور وCSS وJS مؤقتًا على جهاز المستخدم لتسريع التحميل في الزيارات اللاحقة.
9. كاش مستوى التطبيق هو كاش يُنفَّذ داخل التطبيق نفسه ويخزّن بيانات أثناء تشغيله.
10. من أمثلة كاش الـBackend تخزين نتائج استعلامات قاعدة البيانات في الكاش لتفادي إعادة تنفيذ الاستعلام المتكرر.
11. من أمثلة كاش الـFrontend تخزين المتصفح للموارد الثابتة محليًا ليعيد استخدامها دون إعادة تنزيلها.
12. من الفوائد الرئيسية للكاش تقليل العبء على قاعدة البيانات عبر خدمة الطلبات المتكررة من الذاكرة.

## 3. الاتساق والمخاطر
13. قد يحتوي الكاش على بيانات قديمة إذا تغيّرت البيانات في المصدر ولم يتم تحديث الكاش.
14. الكاش يستهلك ذاكرة إضافية وقد يزيد تعقيد التطبيق بسبب منطق التحديث والإبطال.
15. Redis وMemcached وVarnish جميعها أدوات/تقنيات تُستخدم في سياقات التخزين المؤقت.
16. Redis مخزن بيانات داخل الذاكرة يدعم هياكل بيانات متعددة ويمكن استخدامه كخادم كاش لتحسين الأداء.
17. Varnish Cache يُستخدم لتسريع تقديم محتوى الويب عبر التخزين المؤقت أمام خادم الويب.

## 4. الصلاحية وضربات الكاش
18. انتهاء الصلاحية (Expiration) يعني أن العنصر المخبأ يصبح غير صالح بعد مدة/وقت محدد ويجب جلب نسخة أحدث من المصدر.
19. ضربة الكاش (Cache Hit) تعني العثور على البيانات في الكاش وخدمتها دون الرجوع للمصدر الأصلي.
20. معدل إصابة الكاش (Cache Hit Ratio) هو نسبة الطلبات التي خُدمت من الكاش إلى إجمالي الطلبات.
21. الإخلاء (Eviction) هو إزالة عناصر من الكاش عند امتلائه لإفساح مساحة لعناصر جديدة لأن سعة الكاش محدودة.
22. من سياسات الإخلاء الشائعة LRU وLFU (ويمكن أيضًا FIFO).
23. إبطال الكاش (Cache Invalidation) هو تحديث أو إزالة البيانات المخبأة عندما تصبح قديمة لضمان اتساق مع المصدر.
24. TTL تعني Time To Live أي مدة بقاء العنصر صالحًا في الكاش.
25. عند ضبط TTL لعنصر ما، سيُعتبر منتهي الصلاحية بعد انقضاء تلك المدة ويجب تحديثه/إزالته.
26. عند Cache Miss يرجع النظام للمصدر الأساسي لجلب البيانات ثم يمكنه تخزينها في الكاش لتسريع الطلبات اللاحقة.
27. يمكن أن يحتوي النظام على طبقات متعددة من الكاش مثل كاش المتصفح وCDN وكاش الخادم معًا.
28. إذا كانت البيانات تتغير بتواتر شديد جدًا فقد يقل نفع الكاش لأن البيانات تصبح قديمة بسرعة.
29. تخزين بيانات حساسة في كاش مشترك قد يعرّضها للانكشاف أو لهجمات مثل تسميم الكاش، لذلك يلزم الحذر.
30. قد يكون الكاش غير مفيد عندما تتغير البيانات بسرعة كبيرة جدًا لأن التحقق والتحديث المستمر يقلل الفائدة وقد يزيد التعقيد والحمل.

## 5. Redis مقابل Memcached
31. الفرق المؤثر بين Redis وMemcached أن Redis يدعم ميزات مثل الاستمرارية (Persistence) وهياكل بيانات متعددة بينما Memcached عادةً ذاكرة فقط وبنموذج أبسط.
32. Memcached لا يخزّن البيانات على القرص بشكل دائم وتفقد البيانات عند إعادة التشغيل.
33. Redis يدعم هياكل بيانات متعددة مثل القوائم والمجموعات والهاشات إضافةً إلى مفاتيح/قيم.
34. Memcached يستخدم LRU كسياسة إخلاء شائعة/افتراضية عند امتلاء الكاش.
35. Redis يتيح ضبط سياسات إخلاء متعددة، بينما Memcached محدود بسياسات أبسط وأقل تنوعًا.

## 6. رؤوس HTTP الخاصة بالكاش
36. رأس Authorization ليس رأسًا مخصصًا للتحكم في التخزين المؤقت.
37. ETag يعرّف نسخة محددة من المورد بحيث يستطيع العميل التحقق لاحقًا هل تغيّر المورد أم لا باستخدام If-None-Match.
38. رأس If-Modified-Since يستخدمه العميل للتحقق مما إذا كانت النسخة المخبأة لا تزال صالحة على الخادم.
39. no-cache يسمح بالتخزين لكنه يفرض إعادة التحقق قبل الاستخدام، بينما no-store يمنع التخزين المؤقت تمامًا.
40. Cache-Control: private يعني أن الاستجابة تُخزَّن فقط في كاش خاص بالمستخدم ولا تُخزَّن في كاش مشترك.
41. Cache-Control: public يعني أن الاستجابة قابلة للتخزين في كاشات مشتركة مثل CDN والبروكسي.

## 7. أنماط ومشكلات الأداء
42. تدافع الكاش (Cache Stampede) يحدث عند انتهاء عنصر شائع فتتزامن طلبات كثيرة لجلبه فتندفع كلها للمصدر الأصلي.
43. سياسة LFU مناسبة عندما توجد عناصر “ساخنة” ثابتة الشعبية لأنها تُبقي الأكثر تكرارًا في الكاش أطول.
44. في LRU قد يُزال عنصر كان مهمًا تاريخيًا إذا لم يُستخدم مؤخرًا.
45. Cache-Aside يعني أن التطبيق يجلب من المصدر عند Cache Miss ثم يضع النتيجة في الكاش عند الحاجة.
46. Write-Through يكتب إلى الكاش والمصدر الأساسي بشكل متزامن عند كل تحديث.
47. Write-Back يكتب إلى الكاش فورًا ويؤجل كتابة المصدر الأساسي، وهذا يحسن أداء الكتابة لكنه يزيد خطر فقدان بيانات إن تعطل الكاش قبل التفريغ.
48. الاستراتيجية التي تُحمّل البيانات إلى الكاش عند أول طلب فقط هي Cache-Aside.
49. الاستراتيجية التي تُحدّث قاعدة البيانات في نفس لحظة تحديث الكاش لضمان التزامن هي Write-Through.
50. من مؤشرات أداء الكاش معدل إصابة الكاش (Hit Ratio) ومعدل الإخلاء (Eviction Rate).
51. الارتفاع المستمر في معدل الإخلاء قد يعني أن حجم الكاش غير كافٍ أو أن سياسة الإخلاء غير مناسبة.
52. انخفاض Hit Ratio يعني أن عددًا كبيرًا من الطلبات يصل للمصدر الأصلي مما يقلل فعالية الكاش.
53. توسيع الكاش الموزع يزيد السعة لكنه قد يزيد تعقيد الاتساق بين العقد.
54. غياب أو سوء إعداد رؤوس HTTP الخاصة بالكاش قد يمنع المتصفح أو CDN من التخزين المؤقت الفعال.
55. استخدام Redis ككاش موزع مناسب لمشاركة جلسات المستخدم بين عدة خوادم تطبيق بسرعة.
56. الكاش أنفع عندما تكون القراءات متكررة لأن نفس البيانات تُخدم مرات عديدة من الكاش بدل المصدر الأبطأ.
57. يجب ضبط مهلة زمنية لقراءة الكاش والرجوع للمصدر عند بطء/تعطل الكاش لتجنب تأخير الاستجابة.
58. الكاش لا يضمن أن كل القراءات ستحصل على أحدث البيانات لحظيًا، بل قد يقدم بيانات قديمة حسب سياسة التحديث.
59. من الشائع استخدام Cache-Control: no-store مع الصفحات الحساسة لمنع تخزينها في أي كاش.
60. TTL يمنع بقاء بيانات قديمة إلى الأبد عبر إبطال تلقائي بعد مدة محددة إذا لم يحدث إبطال صريح.
61. قد نحتاج لمسح الكاش يدويًا بعد تغييرات كبيرة أو نشرات مهمة لضمان تقديم النسخة الأحدث للمستخدمين.
62. قد يُزال عنصر قبل انتهاء TTL بسبب امتلاء الكاش وتطبيق سياسة إخلاء أو بسبب إبطال صريح من التطبيق.
63. Memcached يعتمد غالبًا على العميل لتوزيع المفاتيح (مثل التجزئة المتسقة) ولا يوفر تكرارًا/عنقدة مترابطة مدمجة بشكل كامل.
64. Cache Busting يتم عبر تغيير URL بإضافة رقم إصدار/مُعرّف فريد للملفات الثابتة لإجبار المتصفح على تنزيل النسخة الجديدة.
65. معدل فقدان الكاش (Miss Ratio) هو نسبة الطلبات التي لم تُخدم من الكاش إلى إجمالي الطلبات ويمكن حسابه كـ 1 − Hit Ratio.
66. التجزئة المتسقة تقلل إعادة توزيع المفاتيح عند إضافة/إزالة عقد في الكاش الموزع.
67. Read-Through Cache يعني أن طبقة الكاش نفسها تجلب البيانات من المصدر عند Cache Miss دون أن يتعامل التطبيق مباشرة مع المصدر في كل مرة.
68. المفتاح الساخن (Hot Key) هو مفتاح يتلقى طلبات هائلة وقد يسبب اختناقًا وعدم توازن، ويُعالج بالتكرار أو التقسيم (Sharding) أو توزيع القراءة عبر نسخ متعددة.
69. كثير من أنظمة الكاش الموزعة تقبل ببيانات قديمة قليلًا مقابل توفر أعلى عند الانقسامات الشبكية.
70. تسميم الكاش (Cache Poisoning) هو إدخال محتوى/استجابة ضارة في الكاش بحيث تُقدَّم لاحقًا لمستخدمين آخرين كأنها صحيحة.
71. من طرق تخفيف Cache Stampede استخدام قفل يسمح لطلب واحد بتحديث الكاش بينما تنتظر بقية الطلبات.
72. لا توجد سياسة إخلاء مثالية لكل الحالات، والاختيار يعتمد على نمط الوصول ومتطلبات النظام وقد يتطلب تجريبًا.
73. التحديث المسبق (Pre-Fetching) هو تحميل البيانات للكاش قبل طلب المستخدم لها وهو مفيد عندما يمكن التنبؤ بالبيانات المطلوبة أو عندما تكون البيانات شديدة الشعبية.
74. الحل غير الصحيح لمشكلة Hot Key هو الاعتقاد أن “التجزئة المتسقة” وحدها ستوزع طلبات نفس المفتاح على عدة عقد، لأن المفتاح الواحد غالبًا يُسند لعقدة واحدة.
75. Stale-While-Revalidate يسمح بتقديم نسخة قديمة مؤقتًا للمستخدم بينما يتم تحديث النسخة الجديدة في الخلفية.
76. إبطال الكاش صعب لأنه يتطلب موازنة الأداء مع الاتساق، ويزداد تعقيده في الأنظمة الموزعة متعددة الطبقات.
77. اختيار سياسة الإخلاء يعتمد على نمط الوصول (حداثة مقابل تكرار) وكلفة التنفيذ والموارد وطبيعة البيانات.
78. إضافة مقدار عشوائي صغير إلى TTL يقلل احتمال انتهاء عناصر كثيرة في نفس اللحظة ويخفف التدافع نحو المصدر.
79. الكاش متعدد المستويات (L1 محلي وL2 موزع) يجمع بين سرعة الذاكرة المحلية وسعة/مشاركة الكاش الموزع.
80. امتلاك كل خدمة في الميكروسيرفس لكاش خاص قد يسبب تكرار البيانات وتحديات اتساق عندما تشترك خدمات متعددة في نفس البيانات.

## 8. الاعتمادية والأمان
81. يجب تصميم النظام بخطة رجوع للمصدر الأساسي عند فشل الكاش لضمان استمرارية الخدمة ولو بأداء أبطأ.
82. TTL القصير جدًا يرفع نسبة الـMiss ويزيد الضغط على المصدر، وTTL الطويل جدًا قد يقدم بيانات قديمة مدة أطول من اللازم.
83. Request Coalescing يجمع عدة طلبات متزامنة لعنصر مفقود في طلب واحد للمصدر ثم يوزع النتيجة لتلبية الجميع.
84. استخدام Mutex/Lock يسمح لطلب واحد فقط بتحديث عنصر منتهي الصلاحية بينما تنتظر بقية الطلبات لتجنب تدافع الاستعلامات.
85. في كاش L1/L2 يتم فحص L1 أولًا لأنه الأسرع ثم L2 لأنه مشترك وأكبر سعة قبل الرجوع للمصدر الأساسي.
86. يمكن تنسيق إبطال الكاش الموزع عبر نشر أحداث/رسائل (Pub/Sub) عند تحديث البيانات بحيث تُبطل/تُحدّث كل العقد نسخها.
87. Redis يدعم العنقدة (Cluster) لتوزيع البيانات والتكرار (Replication) لرفع التوفر وزيادة السعة الإجمالية.
88. Memcached لا يوفر عادةً تكرارًا/عنقدة مترابطة مدمجة، وتوزيع المفاتيح يتم غالبًا من جهة العميل.
89. يجب تأمين خوادم الكاش بالمصادقة وضبط الشبكات لأن الوصول غير المصرح قد يسبب تسريبًا أو تلاعبًا بالبيانات.
90. ارتفاع Hit Ratio لا يضمن أن الأداء مثالي لأن زمن الشبكة أو بطء الكاش أو كلفة التحديث قد تظل تسبب مشاكل أداء.
91. إذا كان الكاش مركزيًا أو محدودًا فقد يصبح هو نفسه عنق زجاجة ويستلزم توزيعًا/توسعة أفقية.
92. Cache Thrashing هو إدخال وإخراج متكرر للعناصر لأن الكاش صغير مقارنة بحجم البيانات العاملة أو بسبب إعدادات غير مناسبة مما يرفع الـMiss.
93. Cache Miss Penalty هو الزمن الإضافي لجلب البيانات من المصدر الأصلي مقارنةً بجلبها من الكاش.
94. رأس Vary يمنع تقديم نسخة مخبأة غير مناسبة عبر التفريق بين نسخ الاستجابة بناءً على رؤوس طلب معينة مثل اللغة أو نوع المتصفح.
95. Write-Around يكتب مباشرة إلى قاعدة البيانات دون وضع فوري في الكاش لتجنب ملء الكاش ببيانات قد لا تُقرأ قريبًا، لكن أول قراءة لاحقة ستكون Cache Miss.
96. إدخال مدخلات غير موثوقة في مفاتيح كاش مشترك قد يسهّل هجمات مثل Cache Poisoning لذلك يجب ضبط المفاتيح بعناية.
97. الاتساق القوي بين كاشات موزعة معقد، لذا تقبل كثير من الأنظمة نموذج اتساق أضعف مثل الاتساق النهائي.
98. Write-Through يُفضّل عندما يكون الاتساق مطلوبًا بقوة لأنه يحدّث الكاش والمصدر معًا رغم زيادة زمن الكتابة.
99. الكاش ليس حلًا بلا حدود؛ قد تفشل الاستفادة منه عند سوء التوزيع أو محدودية السعة أو تغير أنماط الحمل، لذا يلزم التخطيط والمراقبة.
100. يجب مراقبة الكاش وضبط حجمه وسياسات الإخلاء وTTL لأن تغير سلوك المستخدم وحجم البيانات قد يتطلب إعادة تهيئة لتحقيق أفضل أداء.
