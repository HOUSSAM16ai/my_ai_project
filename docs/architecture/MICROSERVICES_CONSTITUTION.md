# دستور الخدمات المصغرة (The Microservices Constitution)

هذه الوثيقة تمثل "القانون الأساسي" لمشروع CogniForge. جميع القرارات المعمارية والبرمجية يجب أن تخضع لهذه القواعد الـ 100 الصارمة.

## المبادئ الأساسية (Core Principles)

1.  **معمارية الخدمات المصغّرة**: هي أسلوب يبني التطبيق على شكل خدمات صغيرة مستقلة لكل منها نطاق أعمال واضح، يمكن تطويرها ونشرها وتوسيعها بشكل مستقل، وتتواصل فيما بينها عبر واجهات برمجية (APIs) محددة.
2.  **التوسع الأفقي**: الميزة الأساسية للخدمات المصغّرة مقارنة بالمونوليث هي إمكانية التوسّع الأفقي لخدمة بعينها دون الحاجة لتوسيع النظام كله.
3.  **النشر المستقل**: يمكن تطوير ونشر كل خدمة مصغّرة بشكل مستقل عن بقية الخدمات داخل النظام.
4.  **التواصل عبر HTTP**: أكثر وسيلة شائعة لتواصل الخدمات المصغّرة هي استهلاك واجهات REST عبر بروتوكول HTTP.
5.  **قواعد البيانات المستقلة**: من أفضل الممارسات أن تمتلك كل خدمة مصغّرة قاعدة بيانات خاصة بها ولا تشاركها مباشرة مع خدمات أخرى.
6.  **تعدد اللغات (Polyglot)**: يمكن بناء الخدمات المصغّرة بلغات وتقنيات مختلفة حسب احتياج كل خدمة.
7.  **الحاويات (Docker)**: تُستخدم الحاويات مثل Docker لعزل تشغيل كل خدمة في بيئة متسقة وقابلة للنقل.
8.  **تنسيق الحاويات (Kubernetes)**: يُستخدم Kubernetes كمنصة تنسيق لإدارة نشر وتشغيل وتوسّع حاويات الخدمات المصغّرة آليًا.
9.  **عزل الأعطال**: عند تعطل خدمة واحدة غالبًا تستمر بقية الخدمات بالعمل مع تأثر محدود، إذا كان النظام مصممًا لعزل الأعطال.
10. **تحدي التعقيد**: من أبرز تحديات الخدمات المصغّرة ازدياد تعقيد الإدارة والتشغيل والمراقبة بسبب الطبيعة الموزعة.

## التصميم والحدود (Design & Boundaries)

11. **واجهات واضحة**: تعرض الخدمات المصغّرة وظائفها عبر واجهات برمجية واضحة (APIs) للتواصل مع بقية الخدمات والعملاء.
12. **استقلالية الفرق**: تمكّن الخدمات المصغّرة الفرق من العمل باستقلالية على خدمات مختلفة مع قدرة نشر تغييراتهم دون تعطيل النظام كله.
13. **خصائص الخدمة الجيدة**: الخدمة المصغّرة الجيدة تكون صغيرة ومركزة على مسؤولية واحدة، ضعيفة الاقتران مع غيرها، وقابلة للنشر المستقل (مع عزل أعطال وامتلاك بياناتها).
14. **CI/CD**: مسارات CI/CD مهمة في الخدمات المصغّرة لأنها تؤتمت الاختبار والبناء والنشر السريع والمتكرر لكل خدمة.
15. **التكامل والتسليم المستمر**: التكامل المستمر (CI) يعني دمج التغييرات واختبارها آليًا باستمرار، والتسليم/النشر المستمر (CD) يعني أتمتة إيصال الإصدارات إلى البيئات وربما الإنتاج بشكل متكرر.
16. **تصحيح الأخطاء**: تصحيح الأخطاء في الخدمات المصغّرة غالبًا أصعب من المونوليث لأنه يتطلب تتبع المشكلة عبر خدمات متعددة وشبكة واتصالات موزعة.
17. **قدرة أعمال واحدة**: يجب أن تركّز كل خدمة مصغّرة على قدرة أعمال واحدة محددة وواضحة ضمن نطاقها.
18. **التوزيع الأفقي للحمل**: تتيح الخدمات المصغّرة التوسّع الأفقي بسهولة عبر تشغيل نسخ متعددة من خدمة معينة لتوزيع الحمل.
19. **ضد قاعدة البيانات المشتركة**: السمة غير الصحيحة في الخدمات المصغّرة هي “استخدام قاعدة بيانات واحدة مشتركة لجميع الخدمات” لأن الأفضل أن تمتلك كل خدمة مخزن بياناتها.
20. **تناسق البيانات**: تحقيق تناسق البيانات بين خدمات متعددة ليس بسيطًا؛ بل هو تحدٍّ ويُعالج عادةً باستراتيجيات مثل التناسق النهائي (Eventual Consistency) وأنماط مثل Saga.

## التماسك والاقتران (Cohesion & Coupling)

21. **الاقتران الضعيف (Loose Coupling)**: يعني تقليل الاعتماد المباشر بين الخدمات بحيث يمكن تغيير أو استبدال خدمة دون كسر غيرها طالما التزمت بعقد الواجهة (API Contract).
22. **ممارسات DevOps**: تتطلب بيئات الخدمات المصغّرة تطبيق ممارسات DevOps بفاعلية بسبب كثرة النشر والمراقبة والأتمتة.
23. **تقليل التعقيد**: تقسيم النظام إلى خدمات صغيرة يقلل تعقيد كل جزء من الشفرة ويجعل كل خدمة أسهل فهمًا وصيانة على حدة.
24. **تعقيد الاختبارات**: الاختبارات تصبح أكثر تعقيدًا لأنك تحتاج لاختبارات وحدات لكل خدمة واختبارات تكامل وعقود بين الخدمات.
25. **المركزية في الأمان**: من الأفضل غالبًا معالجة المصادقة والتفويض مركزيًا عبر بوابة API أو خدمة هوية موحدة بدل تكرار منطق المصادقة داخل كل خدمة.
26. **REST vs gRPC**: REST يعتمد غالبًا على HTTP/JSON ويصلح للواجهات العامة، بينما gRPC يعتمد HTTP/2 ونقلًا ثنائيًا مع تعريف واجهات عبر Proto ويتميز بأداء أعلى وعقود قوية النوع.
27. **الرسائل (Messaging)**: التواصل غير المتزامن الشائع بين الخدمات يكون عبر إرسال الرسائل/الأحداث باستخدام Message Broker مثل RabbitMQ أو Apache Kafka.
28. **بوابة API (Gateway)**: تعمل كمدخل موحّد للنظام فتتولى التوجيه للخدمات، وتطبيق سياسات الأمان، والحد من المعدّل، والتجميع، والتخزين المؤقت.
29. **تجنب 2PC**: المعاملات الموزعة الثقيلة مثل Two-Phase Commit غير محبذة في الخدمات المصغّرة لأنها تقلل الاستقلالية وتزيد التعقيد وتؤثر على الأداء.
30. **نمط Saga**: هو النهج الشائع لتحقيق تناسق عبر خدمات متعددة عبر سلسلة معاملات محلية مع معاملات تعويضية عند الفشل بدل 2PC.

## التشغيل والموثوقية (Operations & Reliability)

31. **النشر الأزرق/الأخضر**: يعني تشغيل إصدار جديد في بيئة موازية للإصدار الحالي ثم تحويل المرور إليه دون توقف.
32. **خفة الحاويات**: الحاويات أخف من الآلات الافتراضية لأنها تشارك نواة نظام التشغيل بدل تشغيل نظام تشغيل كامل لكل وحدة.
33. **Pod**: في Kubernetes هي أصغر وحدة نشر، وقد تضم حاوية واحدة أو أكثر تعمل معًا داخل نفس السياق الشبكي والتخزيني.
34. **Circuit Breaker**: يمنع تكرار الاستدعاءات الفاشلة إلى خدمة متعثرة، فيحمي النظام من الانهيار المتسلسل ويمنح الخدمة وقتًا للتعافي.
35. **Rate Limiting**: يحمي الخدمات عبر تقييد عدد الطلبات خلال فترة زمنية لتجنب الحمل الزائد والهجمات.
36. **التتبع الموزع (Distributed Tracing)**: أدوات مثل Jaeger أو Zipkin تُستخدم للتتبع الموزع لتحديد مسار الطلب عبر خدمات متعددة.
37. **أركان الرصد (Observability)**: هي السجلات Logs والقياسات Metrics والتتبعات Traces.
38. **JWT**: يُستخدم لتمرير هوية المستخدم وصلاحياته بشكل موقّع وآمن بين المكوّنات والخدمات.
39. **اكتشاف الخدمات (Service Discovery)**: آلية لمعرفة عناوين الخدمات ديناميكيًا عبر سجل أو DNS لأن عناوين الحاويات تتغير.
40. **سجلات الخدمات**: مثل Netflix Eureka أو Consul تُستخدم كسجل لاكتشاف الخدمات.

## التطور والاستراتيجية (Evolution & Strategy)

41. **تحديث API**: أفضل ممارسة لتحديث API هي الحفاظ على التوافق العكسي ودعم النسخة القديمة والجديدة لفترة انتقالية.
42. **Bounded Contexts**: كثيرًا ما تُحدَّد حدود الخدمات المصغّرة وفق DDD بحيث تمثل كل خدمة سياق أعمال متماسكًا.
43. **التواصل غير المتزامن**: يزيد فصل الخدمات (Loose Coupling) ويحسن التحملية مقارنة بالاستدعاءات المتزامنة المباشرة.
44. **التناسق النهائي**: الخدمات قد ترى بيانات غير متطابقة لحظيًا لكن النظام يصل إلى حالة تناسق صحيحة بعد معالجة الأحداث.
45. **متى لا تستخدمها**: الخدمات المصغّرة ليست دائمًا الخيار الأفضل للتطبيقات الصغيرة أو الفرق الصغيرة.
46. **السجلات المركزية**: النهج الصحيح للسجلات هو تجميعها مركزيًا (Centralized Logging) للبحث والتحليل.
47. **اختبار العقود**: يضمن أن مزود الـAPI والمستهلكين متوافقون، وأن تحديث خدمة لا يكسر خدمات أخرى تعتمد عليها.
48. **Prometheus**: يُستخدم لجمع القياسات (Metrics) وغالبًا يُعرض عبر Grafana.
49. **موازن التحميل (Load Balancer)**: يوزّع الطلبات على نسخ متعددة من الخدمة لتحسين التوسع والاعتمادية.
50. **فصل الإعدادات**: من الأفضل فصل إعدادات التكوين عن الكود لتسهيل تغيير الإعدادات دون إعادة بناء الخدمة.

## البنية التحتية والأنماط (Infrastructure & Patterns)

51. **12-Factor App**: خدمات كثيرة تلتزم بمبادئ 12-Factor مثل فصل الإعدادات عن الكود وجعل العمليات عديمة الحالة.
52. **عديمة الحالة (Stateless)**: تصميم الخدمات لتكون عديمة الحالة قدر الإمكان يسهل التوسع الأفقي وتوزيع الحمل.
53. **المونوليث الموزع**: علامة سيئة، حيث تكون الخدمات مترابطة لدرجة أنها لا تُنشر ولا تتغير إلا معًا.
54. **Event Streaming**: مثل Apache Kafka، يُستخدم لبناء تفاعل عالي الإنتاجية قائم على الأحداث.
55. **التخزين المؤقت (Caching)**: يحسن الأداء عبر حفظ بيانات/نتائج متكررة (مثل Redis) لتقليل زمن الاستجابة.
56. **Polyglot Persistence**: تعدد مخازن البيانات، كل خدمة تختار نوع قاعدة البيانات الأنسب لوظيفتها.
57. **Idempotency**: تكرار نفس الطلب يعطي نفس النتيجة دون آثار جانبية إضافية.
58. **تحليل المسار الزمني**: التتبع الموزع يساعد على تحديد أين حدث التأخير أو الفشل عبر ربط أجزاء الطلب (Spans).
59. **تشفير الاتصالات**: من الأفضل تشفير الاتصالات بين الخدمات (TLS/HTTPS) حتى داخل الشبكات الداخلية (Zero Trust).
60. **نمط Bulkhead**: يعزل الموارد لكل مكوّن لمنع خدمة مثقلة أو معطلة من التأثير على بقية الخدمات.

## الجودة والأداء (Quality & Performance)

61. **تحديد الحدود**: حدود الخدمة تُحدد وفق نطاق أعمال واضح ومسؤولية واحدة.
62. **Timeouts & Fallbacks**: لمنع تعليق السلسلة بسبب خدمة بطيئة نستخدم Timeouts وCircuit Breaker.
63. **النشر الكناري**: توجيه نسبة صغيرة من المرور للإصدار الجديد ومراقبته ثم التوسع تدريجيًا.
64. **Orchestration vs Choreography**: Orchestration منسق مركزي، Choreography تفاعل لامركزي.
65. **Sidecar Pattern**: إضافة مكوّن مرافق (مثل proxy/logging) بجانب الخدمة دون إدخال ذلك في منطقها.
66. **Service Mesh**: طبقة لإدارة اتصالات خدمة-إلى-خدمة (mTLS، مراقبة، توجيه) دون تغيير كود الخدمات.
67. **CAP Theorem**: في الأنظمة الموزعة، غالبًا تُغلّب الخدمات المصغّرة التوفر (Availability) مع قبول تناسق نهائي (Eventual Consistency).
68. **BFF / Aggregator**: تجميع بيانات عدة خدمات عبر API Composition أو Backend For Frontend.
69. **Graceful Degradation**: استمرار النظام بتقديم وظائف أساسية مع تعطيل ميزات غير حرجة عند الفشل.
70. **Correlation ID**: معرف يُمرر عبر الخدمات لربط السجلات والتتبعات الخاصة بطلب واحد.

## المخاطر والحلول (Risks & Solutions)

71. **التفتيت المفرط**: تفتيت النظام إلى خدمات صغيرة جدًا بشكل مفرط يضر ويزيد التعقيد.
72. **Chaos Engineering**: اختبار متانة النظام بإدخال أعطال مدروسة لاكتشاف نقاط الضعف.
73. **نمط Strangler Fig**: يحول المونوليث إلى خدمات مصغّرة تدريجيًا عبر استبدال الأجزاء جزءًا جزءًا.
74. **إدارة النسخ (Versioning)**: لتغيير API، نضمن التوافق العكسي أو نصدر v2 مع خطة انتقال.
75. **إدارة الأسرار**: تُدار الأسرار بأدوات مثل Vault، لا تُخزن في الكود، وتُحقن وقت النشر.
76. **تقليل Latency**: نُقلل عدد النداءات، نستخدم gRPC/HTTP2، ونضيف Caching.
77. **Gateway vs Mesh**: الـ Gateway لحافة النظام (Clients)، والـ Mesh للاتصالات الداخلية.
78. **Event Sourcing**: تخزين الأحداث كسجل زمني وإعادة بناء الحالة منها.
79. **CQRS**: فصل مسار الكتابة عن القراءة لتحسين الأداء.
80. **Half-Open State**: في Circuit Breaker، يتم تمرير طلبات تجريبية لاختبار تعافي الخدمة.

## المعايير المتقدمة (Advanced Standards)

81. **SOA vs Microservices**: SOA خدمات أكبر وESB مركزي، Microservices خدمات أصغر ومستقلة وSmart Endpoints.
82. **OpenTelemetry**: معيار لجمع Traces/Metrics/Logs بصيغة موحدة.
83. **mTLS**: تشفير بمصادقة متبادلة لضمان Zero Trust بين الخدمات.
84. **ترحيل قواعد البيانات**: يتم عبر تغييرات متوافقة، قراءة/كتابة مزدوجة، ثم حذف القديم.
85. **تحديد الاختناقات**: نبدأ بالمقاييس، ثم التتبعات، ثم السجلات والملفات الشخصية (Profiling).
86. **المونوليث الموزع (تحذير)**: نظام يبدو كخدمات لكنه مترابط بشدة ويفقد فوائد الاستقلالية.
87. **المقاييس الذهبية**: زمن الاستجابة، معدل الأخطاء، ومعدل الطلبات.
88. **gRPC داخليًا**: نفضل gRPC على REST داخليًا للأداء العالي.
89. **الأخطاء المؤقتة**: نستخدم Retries مع Exponential Backoff وIdempotency.
90. **Polyrepo**: من الشائع أن تكون لكل خدمة مستودعها الخاص (أو مجلد معزول تماماً في Monorepo).
91. **Feature Flags**: نشر الميزات معطلة وتفعيلها تدريجيًا.
92. **Deduplication**: لمنع معالجة نفس الحدث مرتين (Idempotency).
93. **المعاملات التعويضية**: خطوات عكسية في Saga لإلغاء آثار خطوات سابقة عند الفشل.
94. **Multi-Region**: تحديات الكمون وتناسق البيانات عبر المناطق الجغرافية.
95. **متزامن vs غير متزامن**: المتزامن للنتيجة الفورية، غير المتزامن لفك الارتباط وتحمل الأعطال.
96. **استهلاك الموارد**: الخدمات المصغّرة قد تستهلك موارد أكثر من المونوليث (Overhead).
97. **تكرار الكود**: مقبول أحياناً لتحقيق الفصل والاستقلالية (DRY vs Independence).
98. **المكتبات المشتركة**: قلل منها؛ الأفضل هو التكامل عبر APIs لتجنب الاقتران الخفي.
99. **BFF (Backend For Frontend)**: خدمة مخصصة لكل واجهة لتحسين التجربة وتقليل النداءات.
100. **قانون كونواي (Conway's Law)**: معمارية النظام تعكس هيكل وتواصل الفرق؛ تنظيم الفرق يجب أن يدعم الاستقلالية.
