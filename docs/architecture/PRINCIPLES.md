# مبادئ تصميم البرمجيات المتطورة

## أولًا: مبادئ SOLID الأساسية

| المبدأ | الشرح |
|--------|-------|
| **S** - المسؤولية الواحدة | كل وحدة برمجية لها مهمة واحدة فقط |
| **O** - مفتوح/مغلق | مفتوح للتوسع، مغلق للتعديل |
| **L** - استبدال ليسكوف | الأصناف الفرعية تحل محل الأصناف الأب |
| **I** - فصل الواجهات | واجهات صغيرة ومتخصصة |
| **D** - عكس التبعية | الاعتماد على التجريدات لا التفاصيل |

## ثانيًا: الهندسة المعمارية

- **الخدمات المصغرة** (Microservices)
- **الطبقات المنفصلة** (Layered Architecture)
- **التصميم المدفوع بالأحداث** (Event-Driven)
- **فصل الاهتمامات** (Separation of Concerns)

## ثالثًا: الجودة والموثوقية

- ✅ الاختبارات الآلية الشاملة
- ✅ التكامل المستمر (CI/CD)
- ✅ مراجعة الكود
- ✅ التوثيق الجيد

## رابعًا: الأداء والتوسع

- التخزين المؤقت (Caching)
- موازنة الأحمال (Load Balancing)
- التصميم القابل للتوسع الأفقي

## خامسًا: الأمان

- التشفير
- المصادقة والتفويض
- الحماية من الثغرات الشائعة

## سادسًا: مبادئ عامة مهمة

```
• DRY - لا تكرر نفسك
• KISS - أبقِ الأمور بسيطة
• YAGNI - لن تحتاجه (لا تبني ما لا تحتاج)
```

---

## مبادئ أساسية للنظام مع تطبيقها عمليًا

> الهدف من هذه القائمة هو تحويل المبادئ إلى قواعد تشغيلية يومية يمكن تطبيقها في الشيفرة، التصميم، الاختبار، والعمليات.

1. **مبدأ المسؤولية الواحدة (SRP):** كل صنف له سبب واحد للتغيير.  
   **التطبيق العملي:** عند ملاحظة صنف يدمج منطق الأعمال مع الوصول للبيانات، قسّمه إلى صنف مجال وصنف مستودع مستقل.

2. **مبدأ الفتح/الإغلاق (OCP):** الشيفرة مفتوحة للإضافة ومغلقة للتعديل.  
   **التطبيق العملي:** استخدم واجهة Strategy لإضافة خوارزميات جديدة دون تعديل المنطق القائم.

3. **KISS ليس من مبادئ SOLID:** بسيط وواضح لكنه مستقل عن SOLID.  
   **التطبيق العملي:** عند تصميم مكوّن جديد، فضّل أبسط بنية تلبي المتطلبات بدل تعقيد استباقي.

4. **مبدأ DRY:** لا تكرّر الشيفرة.  
   **التطبيق العملي:** استخرج التحقق المتكرر من المدخلات إلى دالة مساعدة مشتركة.

5. **مبدأ KISS:** أبقِ التصميم بسيطًا قدر الإمكان.  
   **التطبيق العملي:** عند وجود حلّين، اختر الأقل في عدد الطبقات والتبعيات.

6. **مبدأ YAGNI:** لا تضف ميزات غير مطلوبة الآن.  
   **التطبيق العملي:** لا تُدخل آلية Plug-in إذا لم يكن هناك حالة استخدام واضحة لها.

7. **الاعتمادية الطبقية في Layered Architecture:** تعتمد الطبقة العليا على التي تحتها مباشرة.  
   **التطبيق العملي:** طبقة العرض تستدعي الخدمات فقط، والخدمات تستدعي المستودعات.

8. **Event-Driven Architecture:** التواصل عبر أحداث على ناقل رسائل.  
   **التطبيق العملي:** خدمة الطلبات تنشر حدث `OrderCreated` وتستهلكه خدمة المخزون.

9. **EDA تفك الترابط:** تقليل الاعتماد المباشر بين المكوّنات.  
   **التطبيق العملي:** استبدل مكالمة متزامنة بين خدمتين بحدث غير متزامن.

10. **Singleton يقيّد الإنشاء:** كائن وحيد ونقطة وصول واحدة.  
    **التطبيق العملي:** استخدمه بحذر في مكوّن إعدادات ثابتة، وتجنب منطق الأعمال داخله.

11. **Factory Method:** إنشاء كائنات دون معرفة الصنف الملموس.  
    **التطبيق العملي:** عميل يولّد بوابة دفع عبر مصنع يعتمد على نوع المزود.

12. **Strategy:** تبديل الخوارزمية وقت التشغيل.  
    **التطبيق العملي:** تغيير خوارزمية التسعير حسب خطة العميل.

13. **Observer:** إخطار المراقبين عند تغيّر الحالة.  
    **التطبيق العملي:** عند تحديث حالة شحنة، يتم إخطار واجهة التتبع.

14. **Adapter:** مواءمة واجهتين مختلفتين.  
    **التطبيق العملي:** تغليف مكتبة خارجية لتطابق واجهة النظام القياسية.

15. **Monolith vs Microservices:** كتلة واحدة مقابل خدمات مستقلة.  
    **التطبيق العملي:** ابدأ بنواة موحّدة ثم استخرج الخدمات ذات الحدود الواضحة.

16. **استقلال نشر الخدمات المصغرة:** كل خدمة تُنشر منفصلة.  
    **التطبيق العملي:** خط CI/CD منفصل لكل خدمة.

17. **محدودية التوسع في المونوليث:** صعب توسيع جزء دون الكل.  
    **التطبيق العملي:** إذا كان ضغط الطلبات على جزء واحد، فكر في تفكيكه لخدمة.

18. **UML للنمذجة:** لغة نمذجة وتصميم بصري.  
    **التطبيق العملي:** استخدام مخطط بسيط في مراجعة المتطلبات المعقدة.

19. **Class Diagram:** نمذجة البنية الثابتة.  
    **التطبيق العملي:** توضيح العلاقات بين الكيانات قبل التنفيذ.

20. **Sequence Diagram:** تتابع الرسائل زمنيًا.  
    **التطبيق العملي:** توثيق رحلة الطلب عبر الخدمات.

21. **User Story:** متطلب من منظور المستخدم.  
    **التطبيق العملي:** صياغة قصة مستخدم لكل ميزة مع معايير قبول.

22. **CI/CD:** التكامل والتسليم/النشر المستمر.  
    **التطبيق العملي:** كل دمج للفرع الرئيسي يطلق اختبارات آلية.

23. **CI:** دمج تغييرات متكرر مع اختبارات.  
    **التطبيق العملي:** منع الدمج عند فشل الاختبارات الأساسية.

24. **Unit Test:** اختبار وحدة صغيرة معزولة.  
    **التطبيق العملي:** اختبار دالة حساب الضريبة بمعزل عن قاعدة البيانات.

25. **Integration Test:** اختبار عمل الوحدات معًا.  
    **التطبيق العملي:** اختبار تدفق إنشاء الطلب مع خدمة الدفع الوهمية.

26. **Refactoring لا يغيّر السلوك:** تحسين البنية فقط.  
    **التطبيق العملي:** استخراج دوال أصغر دون تغيير المدخلات/المخرجات.

27. **100% تغطية لا تعني خلو الأخطاء:** التغطية ليست ضمانًا.  
    **التطبيق العملي:** ركّز على حالات الحافة وسيناريوهات الفشل.

28. **تخزين كلمات المرور كنص واضح غير آمن:** حتى لو الوصول محدود.  
    **التطبيق العملي:** استخدام خوارزميات Hash قوية مع Salt.

29. **Redundancy يحسن الموثوقية:** تكرار المكونات.  
    **التطبيق العملي:** نشر خدمة حرجة بمثيلات متعددة مع موازن حمل.

30. **تشفير/هاش البيانات الحساسة:** قبل التخزين أو أثناء النقل.  
    **التطبيق العملي:** استخدام TLS للنقل وتشفير الحقول الحساسة.

31. **Java وC# لغات كائنية:** أمثلة على OOP.  
    **التطبيق العملي:** اختيار اللغة حسب الفريق ومتطلبات المنصة.

32. **Python ديناميكية:** ليست ثابتة وقت الترجمة.  
    **التطبيق العملي:** استخدام Type Hints وتقنيات فحص ثابت لتحسين الجودة.

33. **C# شائعة لتطوير .NET:** استخدام واسع.  
    **التطبيق العملي:** اعتمادها عند الاستثمار في بيئة .NET.

34. **Python لتحليل البيانات وتعلم الآلة:** وفرة مكتبات.  
    **التطبيق العملي:** توظيفها لخدمات التحليلات والنمذجة.

35. **Inversion of Control ليس من SOLID:** لكنه مبدأ بنيوي.  
    **التطبيق العملي:** استخدام الحاويات لحقن التبعيات بدل إنشائها داخليًا.

36. **Square كفرع من Rectangle قد ينتهك LSP:** سلوك غير متوافق.  
    **التطبيق العملي:** تجنّب الوراثة عندما تتعارض العقود.

37. **DIP:** الاعتماد على التجريدات لا التفاصيل.  
    **التطبيق العملي:** الخدمات تعتمد على واجهات مستودعات وليس على ORM مباشرة.

38. **Ports & Adapters = Hexagonal:** فصل المنافذ والمهايئات.  
    **التطبيق العملي:** عزل منطق المجال عن بنية التخزين أو الشبكة.

39. **Microkernel مناسب للإضافات:** نواة صغيرة قابلة للتوسعة.  
    **التطبيق العملي:** نظام تقارير يسمح بإضافة مولّدات جديدة عبر Plug-ins.

40. **Layered Architecture:** فصل المسؤوليات مع تكلفة عبور الطبقات.  
    **التطبيق العملي:** تجنّب طبقات زائدة غير ضرورية.

41. **Factory Method vs Abstract Factory:** أفراد مقابل عائلات كائنات.  
    **التطبيق العملي:** استخدام Abstract Factory عندما تحتاج مجموعة مترابطة.

42. **Decorator:** إضافة وظائف ديناميكيًا دون تعديل الأصل.  
    **التطبيق العملي:** تغليف خدمة لتفعيل كاش أو سجل.

43. **Observer في واجهات المستخدم:** عبر Listeners.  
    **التطبيق العملي:** ربط زر بمتعدد مستمعين لسيناريوهات مختلفة.

44. **مخاطر Singleton:** حالة عالمية خفية ومشاكل اختبار.  
    **التطبيق العملي:** قلّل استخدامه واعتمد DI بدلاً منه.

45. **Memento:** حفظ الحالة للاسترجاع.  
    **التطبيق العملي:** تنفيذ Undo في محرّر نصوص.

46. **Strategy vs State:** تبديل خوارزمية مقابل سلوك حسب الحالة.  
    **التطبيق العملي:** تسعير = Strategy، دورة حياة الطلب = State.

47. **Proxy:** وسيط للتحكم في الوصول.  
    **التطبيق العملي:** تأخير تهيئة كائن مكلف حتى الحاجة.

48. **Template Method:** هيكل خوارزمية مع خطوات مؤجلة.  
    **التطبيق العملي:** صنف أب يحدد سير المعالجة، والفروع تنفذ التفاصيل.

49. **قاعدة بيانات مستقلة لكل خدمة:** تقليل الاقتران.  
    **التطبيق العملي:** منع مشاركة مخطط قاعدة البيانات عبر الخدمات.

50. **التوسع العمودي vs الأفقي:** موارد الخادم مقابل زيادة الخوادم.  
    **التطبيق العملي:** استخدام الأفقي للتعامل مع الارتفاعات الحادة في الحمل.

51. **فوائد وعيوب Microservices:** نشر مستقل مقابل تعقيد تشغيل.  
    **التطبيق العملي:** تبنّيها عند الحاجة لتوسع مستقل حقيقي.

52. **Monolith قد يكون أفضل أولًا:** بساطة التطوير والنشر.  
    **التطبيق العملي:** البدء بمونوليث منظم قبل التفكيك.

53. **DDD:** نمذجة حسب المجال بالتعاون مع الخبراء.  
    **التطبيق العملي:** جلسات نمذجة مشتركة مع مالك المنتج.

54. **Bounded Context:** سياقات منفصلة لنماذج المجال.  
    **التطبيق العملي:** فصل السياق المالي عن سياق الشحن.

55. **Ubiquitous Language:** لغة مشتركة في التواصل والشيفرة.  
    **التطبيق العملي:** توحيد المصطلحات داخل الكود والوثائق.

56. **Network Flow Diagram ليس UML قياسيًا:** توضيح مهم.  
    **التطبيق العملي:** استخدامه كوثيقة مستقلة إن لزم.

57. **Code Review:** مراجعة زملاء لتحسين الجودة.  
    **التطبيق العملي:** فرض مراجعة لكل طلب دمج.

58. **Acceptance Testing:** تحقق من متطلبات العمل.  
    **التطبيق العملي:** اختبارات سيناريوهات المستخدم النهائية.

59. **Continuous Delivery vs Deployment:** قرار نشر بشري مقابل تلقائي.  
    **التطبيق العملي:** اعتماد Delivery في الأنظمة الحساسة.

60. **git merge:** دمج تغييرات فرع.  
    **التطبيق العملي:** دمج فرع ميزة بعد مراجعة واختبارات.

61. **Jenkins أداة CI وليس VCS:** توضيح الدور.  
    **التطبيق العملي:** استخدامه لتشغيل البِناء والاختبارات.

62. **Static Analysis:** فحص دون تشغيل.  
    **التطبيق العملي:** تشغيل تحليل ساكن في خط CI.

63. **Code Smell:** مؤشرات تصميم سيئ.  
    **التطبيق العملي:** علاج God Object عبر تقسيم المسؤوليات.

64. **Least Privilege:** أقل صلاحيات لازمة.  
    **التطبيق العملي:** حساب خدمة بحدود وصول محددة فقط.

65. **SQL Injection:** نتيجة إدخال غير معقم.  
    **التطبيق العملي:** استخدام Prepared Statements دائمًا.

66. **Defense in Depth:** طبقات متعددة من الحماية.  
    **التطبيق العملي:** WAF + مصادقة + مراقبة.

67. **Authentication vs Authorization:** تحقق هوية مقابل صلاحيات.  
    **التطبيق العملي:** فصل طبقة المصادقة عن طبقة السياسات.

68. **صنف متعدد المسؤوليات ينتهك SRP:** يحتاج تفكيك.  
    **التطبيق العملي:** تفكيك صنف ضخم إلى أصناف صغيرة.

69. **SOLID يحسن الصيانة والتوسع:** عبر تقليل الاقتران.  
    **التطبيق العملي:** مراجعة تصميمية دورية لضمان الالتزام.

70. **Layered vs Hexagonal:** تسلسل طبقات مقابل عزل المجال.  
    **التطبيق العملي:** اختيار Hexagonal عندما نحتاج مرونة تبديل البنى.

71. **Microservices vs Microkernel:** خدمات مستقلة مقابل نواة وإضافات.  
    **التطبيق العملي:** اختيار Microkernel للأنظمة القابلة للتوسعة.

72. **تحديات EDA:** تتبع وعدم فقد الرسائل.  
    **التطبيق العملي:** استخدام Correlation IDs ومستهلكين idempotent.

73. **Singleton نمط إنشائي:** من الـ Creational Patterns.  
    **التطبيق العملي:** توثيق سبب استخدامه بوضوح.

74. **تخفيف مخاطر Singleton:** DI وتقليل الحالة العالمية.  
    **التطبيق العملي:** بناء خدمات عديمة الحالة قدر الإمكان.

75. **Proxy للتحكم في الوصول:** تأخير/تخزين/صلاحيات.  
    **التطبيق العملي:** Proxy يضيف كاش لطلبات مكلفة.

76. **Template Method:** هيكل ثابت وخطوات متخصصة.  
    **التطبيق العملي:** معالجة ملفات عبر خطوات ثابتة.

77. **Strategy vs State (إعادة توكيد):** خوارزميات مقابل حالات.  
    **التطبيق العملي:** اختيار النمط المناسب حسب طبيعة التغيّر.

78. **Command:** تغليف الطلب في كائن.  
    **التطبيق العملي:** جدولة أو تنفيذ Undo للعمليات.

79. **High Availability:** تكرار وموازن حمل وFailover.  
    **التطبيق العملي:** إزالة نقطة الفشل الواحدة.

80. **متزامن vs غير متزامن:** انتظار مقابل عدم انتظار.  
    **التطبيق العملي:** استخدام غير متزامن للمهام الخلفية.

81. **Eventual Consistency:** اتساق نهائي مقبول أحيانًا.  
    **التطبيق العملي:** قبول التأخير في التقارير غير الحرجة.

82. **UML في الأجايل:** خفيف ومحدث عند الحاجة.  
    **التطبيق العملي:** مخططات مختصرة تدعم الحوار فقط.

83. **Bounded Context (إعادة توكيد):** حدود واضحة للنموذج.  
    **التطبيق العملي:** توثيق الحدود بين السياقات.

84. **Aggregate في DDD:** وحدة اتساق مع Root.  
    **التطبيق العملي:** تعديل الكيانات عبر Aggregate Root فقط.

85. **CI/CD يحسن الجودة والسرعة:** بناء واختبارات تلقائية.  
    **التطبيق العملي:** بوابات جودة تمنع إدخال كود معيب.

86. **Code Review الفعّالة:** تغييرات صغيرة ومعايير واضحة.  
    **التطبيق العملي:** قائمة تدقيق لكل مراجعة.

87. **مثال Code Smell:** دالة طويلة متعددة المسؤوليات.  
    **التطبيق العملي:** استخراج دوال صغيرة قابلة للاختبار.

88. **معالجة Technical Debt:** سداد تدريجي.  
    **التطبيق العملي:** تخصيص وقت ثابت في كل Sprint.

89. **Refactoring يحسن الصيانة:** دون تغيير السلوك.  
    **التطبيق العملي:** إعادة تنظيم بدون تعديل المخرجات.

90. **تجنب SQL Injection:** Prepared Statements وLeast Privilege.  
    **التطبيق العملي:** مراجعة كل استعلام ديناميكي.

91. **تخفيف DDoS:** CDN وWAF وRate Limiting.  
    **التطبيق العملي:** إعداد قواعد حماية وتوسع تلقائي.

92. **ثلاثية CIA:** سرية وتكامل وتوافر.  
    **التطبيق العملي:** تقييم أي ميزة وفق هذه الثلاثية.

93. **Spring وASP.NET Core:** أطر تسرّع التطوير.  
    **التطبيق العملي:** اعتماد إطار عند الحاجة لمزايا جاهزة.

94. **.NET تدعم تعددية اللغات:** C# وF# وVB.NET.  
    **التطبيق العملي:** اختيار اللغة حسب المجال داخل نفس المنصة.

95. **Dependency Injection:** حقن التبعيات بدل إنشائها داخليًا.  
    **التطبيق العملي:** تسهيل الاختبار عبر حقن بدائل وهمية.

96. **إدارة الذاكرة:** GC في Java/C# مقابل يدوي في C++.  
    **التطبيق العملي:** الموازنة بين الأداء وسلامة الذاكرة.

97. **JVM وCLR:** تشغيل عبر Bytecode/IL وJIT.  
    **التطبيق العملي:** توقع سلوك الأداء مع الترجمة وقت التشغيل.

98. **الأداء مقابل سرعة التطوير:** C++/Rust للأداء، Python للسرعة.  
    **التطبيق العملي:** اختيار التقنية وفق احتياجات المشروع.

99. **تشغيل C# عبر IL وCLR على أنظمة متعددة:** قابلية نقل.  
    **التطبيق العملي:** نشر الخدمة على لينكس عند توفر runtime.

100. **JVM تستخدم JIT لتحسين الأداء:** ترجمة وقت التشغيل.  
    **التطبيق العملي:** مراقبة الأداء بعد الإحماء (warm-up).

---

## تطبيق عميق للمبادئ على المشروع (خارطة تنفيذية احترافية)

> هذا القسم يربط المبادئ مع القرارات اليومية في التصميم والتنفيذ والاختبار والتشغيل داخل هذا المستودع.

### 1) نواة النظام كمسار وظيفي واضح (Functional Core, Imperative Shell)
- **القاعدة:** اجعل منطق المجال في دوال نقية تُستدعى من طبقات حدودية (I/O).  
- **التطبيق:** أي تفاعل مع الشبكة/القرص/القواعد يبقى في حواف النظام، بينما تُبنى القواعد داخل دوال مستقلة قابلة للاختبار.  
- **مؤشر الالتزام:** اختبارات الوحدة تغطي المنطق دون الحاجة لبنية تشغيل خارجية.

### 2) عزل الخدمات المصغّرة فعليًا وليس نظريًا
- **القاعدة:** كل خدمة في `microservices/` هي جزيرة مستقلة.  
- **التطبيق:** لا استدعاء مباشر لقاعدة بيانات خدمة أخرى، ولا مشاركة منطق أعمال عبر مكتبات مشتركة.  
- **مؤشر الالتزام:** أي تكامل يتم عبر HTTP/gRPC أو أحداث، وليس مشاركة جداول أو طبقات ORM.

### 3) تطبيق SRP عبر تقسيم واضح للمسؤوليات
- **القاعدة:** الصنف/الوحدة لا يُغير إلا لسبب واحد.  
- **التطبيق:** عندما ترى ملفًا يجمع بين تحويل البيانات والتحقق والتخزين، افصل كل مسؤولية في وحدة منفصلة.  
- **مؤشر الالتزام:** كل ملف لديه مهمة محددة وواضحة ومختبرة.

### 4) تطبيق OCP عبر التوسعة لا التعديل
- **القاعدة:** التعديل يكون بإضافة وحدات جديدة لا بفتح منطق قائم.  
- **التطبيق:** استخدم واجهات Strategy/Factory لإضافة سياسات جديدة (مثلاً قواعد تسعير/تحقق).  
- **مؤشر الالتزام:** إضافة ميزة جديدة لا يتطلب تعديل مسارات التنفيذ الأساسية.

### 5) DRY دون كسر الاستقلالية
- **القاعدة:** لا تكرار داخل الخدمة نفسها، لكن لا تنقل منطق أعمال مشترك بين الخدمات.  
- **التطبيق:** كرّر منطق الأعمال بين الخدمات عند الحاجة للحفاظ على استقلالية الخدمات، وقلّل التكرار داخل نفس الخدمة عبر وحدات مشتركة محلية.  
- **مؤشر الالتزام:** لا توجد مكتبات أعمال مشتركة عابرة للخدمات.

### 6) KISS وYAGNI كفلتر قرار يومي
- **القاعدة:** البساطة أولًا وعدم بناء ما لا تحتاجه.  
- **التطبيق:** لا تُدخل طبقة جديدة أو نظام Plug-in إلا عندما تظهر متطلبات مؤكدة، وليس توقعات.  
- **مؤشر الالتزام:** كل تعقيد له سبب تشغيلي واضح ومثبت.

### 7) Layered Architecture دون تكديس طبقات
- **القاعدة:** كل طبقة تتعامل مع الطبقة التي تحتها مباشرة.  
- **التطبيق:** واجهة/تحكم → خدمات مجال → مستودعات/بوابات تكامل.  
- **مؤشر الالتزام:** لا يوجد استدعاء مباشر من الواجهة إلى التخزين.

### 8) Event-Driven Architecture لفك الترابط
- **القاعدة:** الأحداث تنقل النية لا التنفيذ.  
- **التطبيق:** صغ رسائل حدث صغيرة ودلالية مع `Correlation ID` لتتبع المسار.  
- **مؤشر الالتزام:** تعطل مستهلك حدث لا يكسر المنتج الأساسي.

### 9) DIP لعزل التفاصيل التقنية
- **القاعدة:** منطق الأعمال يعتمد على تجريدات لا تفاصيل.  
- **التطبيق:** اجعل الطبقة العليا تتعامل مع واجهات، ثم وفّر تنفيذات للبنية التحتية.  
- **مؤشر الالتزام:** استبدال قاعدة بيانات لا يتطلب تغيير منطق الأعمال.

### 10) استراتيجية اختبار متدرجة واقعية
- **القاعدة:** وحدة → تكامل → قبول.  
- **التطبيق:**  
  - **Unit:** اختبارات نقية لمنطق المجال.  
  - **Integration:** التحقق من تكامل الخدمات والبوابات.  
  - **Acceptance:** سيناريوهات عمل حقيقية.  
- **مؤشر الالتزام:** كل طبقة اختبار تمتلك هدفًا محددًا ولا تكرر دور الطبقات الأخرى.

### 11) الأمن كقيد تصميمي دائم
- **القاعدة:** لا تخزين لبيانات حساسة بدون تشفير/هاش.  
- **التطبيق:** TLS للاتصال، وHash لكلمات المرور، وLeast Privilege لكل حساب.  
- **مؤشر الالتزام:** أي وحدة تخزين تحتوي على سياسة حماية واضحة ومراجَعة.

### 12) الاتساق النهائي بوعي
- **القاعدة:** الاتساق النهائي خيار معماري وليس حادثًا.  
- **التطبيق:** استخدمه فقط عند قبول تأخير البيانات مع توثيق ذلك للمستخدمين.  
- **مؤشر الالتزام:** توجد رسائل توضيحية في عمليات التقارير والتزامن.

### 13) سياسات تشغيل عالية التوفر
- **القاعدة:** لا نقطة فشل واحدة.  
- **التطبيق:** موازن حمل + تكرار خدمات حرجة + مراقبة.  
- **مؤشر الالتزام:** فشل مثيل واحد لا يوقف الخدمة.

### 14) مراجعة الكود كحاجز جودة
- **القاعدة:** كل تعديل يجب أن يكون صغيرًا وقابلًا للفحص.  
- **التطبيق:** قائمة تدقيق ثابتة تشمل: SRP/OCP، الأمن، الاختبارات.  
- **مؤشر الالتزام:** لا دمج بدون اختبارات أو مراجعة.

### 15) توثيق حيّ ومباشر
- **القاعدة:** التوثيق يصف السلوك وليس الشعار.  
- **التطبيق:** أي تغيير في بنية النظام يُوثّق مباشرة في `docs/architecture`.  
- **مؤشر الالتزام:** الوثائق تسبق أو تواكب التغيير.
