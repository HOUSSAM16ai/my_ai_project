# مبادئ تصميم البرمجيات المتطورة

## أولًا: مبادئ SOLID الأساسية

| المبدأ | الشرح |
|--------|-------|
| **S** - المسؤولية الواحدة | كل وحدة برمجية لها مهمة واحدة فقط |
| **O** - مفتوح/مغلق | مفتوح للتوسع، مغلق للتعديل |
| **L** - استبدال ليسكوف | الأصناف الفرعية تحل محل الأصناف الأب |
| **I** - فصل الواجهات | واجهات صغيرة ومتخصصة |
| **D** - عكس التبعية | الاعتماد على التجريدات لا التفاصيل |

## ثانيًا: الهندسة المعمارية

- **الخدمات المصغرة** (Microservices)
- **الطبقات المنفصلة** (Layered Architecture)
- **التصميم المدفوع بالأحداث** (Event-Driven)
- **فصل الاهتمامات** (Separation of Concerns)

## ثالثًا: الجودة والموثوقية

- ✅ الاختبارات الآلية الشاملة
- ✅ التكامل المستمر (CI/CD)
- ✅ مراجعة الكود
- ✅ التوثيق الجيد

## رابعًا: الأداء والتوسع

- التخزين المؤقت (Caching)
- موازنة الأحمال (Load Balancing)
- التصميم القابل للتوسع الأفقي

## خامسًا: الأمان

- التشفير
- المصادقة والتفويض
- الحماية من الثغرات الشائعة

## سادسًا: مبادئ عامة مهمة

```
• DRY - لا تكرر نفسك
• KISS - أبقِ الأمور بسيطة
• YAGNI - لن تحتاجه (لا تبني ما لا تحتاج)
```

---

## مبادئ أساسية للنظام مع تطبيقها عمليًا

> الهدف من هذه القائمة هو تحويل المبادئ إلى قواعد تشغيلية يومية يمكن تطبيقها في الشيفرة، التصميم، الاختبار، والعمليات.

1. **مبدأ المسؤولية الواحدة (SRP):** كل صنف له سبب واحد للتغيير.  
   **التطبيق العملي:** عند ملاحظة صنف يدمج منطق الأعمال مع الوصول للبيانات، قسّمه إلى صنف مجال وصنف مستودع مستقل.

2. **مبدأ الفتح/الإغلاق (OCP):** الشيفرة مفتوحة للإضافة ومغلقة للتعديل.  
   **التطبيق العملي:** استخدم واجهة Strategy لإضافة خوارزميات جديدة دون تعديل المنطق القائم.

3. **KISS ليس من مبادئ SOLID:** بسيط وواضح لكنه مستقل عن SOLID.  
   **التطبيق العملي:** عند تصميم مكوّن جديد، فضّل أبسط بنية تلبي المتطلبات بدل تعقيد استباقي.

4. **مبدأ DRY:** لا تكرّر الشيفرة.  
   **التطبيق العملي:** استخرج التحقق المتكرر من المدخلات إلى دالة مساعدة مشتركة.

5. **مبدأ KISS:** أبقِ التصميم بسيطًا قدر الإمكان.  
   **التطبيق العملي:** عند وجود حلّين، اختر الأقل في عدد الطبقات والتبعيات.

6. **مبدأ YAGNI:** لا تضف ميزات غير مطلوبة الآن.  
   **التطبيق العملي:** لا تُدخل آلية Plug-in إذا لم يكن هناك حالة استخدام واضحة لها.

7. **الاعتمادية الطبقية في Layered Architecture:** تعتمد الطبقة العليا على التي تحتها مباشرة.  
   **التطبيق العملي:** طبقة العرض تستدعي الخدمات فقط، والخدمات تستدعي المستودعات.

8. **Event-Driven Architecture:** التواصل عبر أحداث على ناقل رسائل.  
   **التطبيق العملي:** خدمة الطلبات تنشر حدث `OrderCreated` وتستهلكه خدمة المخزون.

9. **EDA تفك الترابط:** تقليل الاعتماد المباشر بين المكوّنات.  
   **التطبيق العملي:** استبدل مكالمة متزامنة بين خدمتين بحدث غير متزامن.

10. **Singleton يقيّد الإنشاء:** كائن وحيد ونقطة وصول واحدة.  
    **التطبيق العملي:** استخدمه بحذر في مكوّن إعدادات ثابتة، وتجنب منطق الأعمال داخله.

11. **Factory Method:** إنشاء كائنات دون معرفة الصنف الملموس.  
    **التطبيق العملي:** عميل يولّد بوابة دفع عبر مصنع يعتمد على نوع المزود.

12. **Strategy:** تبديل الخوارزمية وقت التشغيل.  
    **التطبيق العملي:** تغيير خوارزمية التسعير حسب خطة العميل.

13. **Observer:** إخطار المراقبين عند تغيّر الحالة.  
    **التطبيق العملي:** عند تحديث حالة شحنة، يتم إخطار واجهة التتبع.

14. **Adapter:** مواءمة واجهتين مختلفتين.  
    **التطبيق العملي:** تغليف مكتبة خارجية لتطابق واجهة النظام القياسية.

15. **Monolith vs Microservices:** كتلة واحدة مقابل خدمات مستقلة.  
    **التطبيق العملي:** ابدأ بنواة موحّدة ثم استخرج الخدمات ذات الحدود الواضحة.

16. **استقلال نشر الخدمات المصغرة:** كل خدمة تُنشر منفصلة.  
    **التطبيق العملي:** خط CI/CD منفصل لكل خدمة.

17. **محدودية التوسع في المونوليث:** صعب توسيع جزء دون الكل.  
    **التطبيق العملي:** إذا كان ضغط الطلبات على جزء واحد، فكر في تفكيكه لخدمة.

18. **UML للنمذجة:** لغة نمذجة وتصميم بصري.  
    **التطبيق العملي:** استخدام مخطط بسيط في مراجعة المتطلبات المعقدة.

19. **Class Diagram:** نمذجة البنية الثابتة.  
    **التطبيق العملي:** توضيح العلاقات بين الكيانات قبل التنفيذ.

20. **Sequence Diagram:** تتابع الرسائل زمنيًا.  
    **التطبيق العملي:** توثيق رحلة الطلب عبر الخدمات.

21. **User Story:** متطلب من منظور المستخدم.  
    **التطبيق العملي:** صياغة قصة مستخدم لكل ميزة مع معايير قبول.

22. **CI/CD:** التكامل والتسليم/النشر المستمر.  
    **التطبيق العملي:** كل دمج للفرع الرئيسي يطلق اختبارات آلية.

23. **CI:** دمج تغييرات متكرر مع اختبارات.  
    **التطبيق العملي:** منع الدمج عند فشل الاختبارات الأساسية.

24. **Unit Test:** اختبار وحدة صغيرة معزولة.  
    **التطبيق العملي:** اختبار دالة حساب الضريبة بمعزل عن قاعدة البيانات.

25. **Integration Test:** اختبار عمل الوحدات معًا.  
    **التطبيق العملي:** اختبار تدفق إنشاء الطلب مع خدمة الدفع الوهمية.

26. **Refactoring لا يغيّر السلوك:** تحسين البنية فقط.  
    **التطبيق العملي:** استخراج دوال أصغر دون تغيير المدخلات/المخرجات.

27. **100% تغطية لا تعني خلو الأخطاء:** التغطية ليست ضمانًا.  
    **التطبيق العملي:** ركّز على حالات الحافة وسيناريوهات الفشل.

28. **تخزين كلمات المرور كنص واضح غير آمن:** حتى لو الوصول محدود.  
    **التطبيق العملي:** استخدام خوارزميات Hash قوية مع Salt.

29. **Redundancy يحسن الموثوقية:** تكرار المكونات.  
    **التطبيق العملي:** نشر خدمة حرجة بمثيلات متعددة مع موازن حمل.

30. **تشفير/هاش البيانات الحساسة:** قبل التخزين أو أثناء النقل.  
    **التطبيق العملي:** استخدام TLS للنقل وتشفير الحقول الحساسة.

31. **Java وC# لغات كائنية:** أمثلة على OOP.  
    **التطبيق العملي:** اختيار اللغة حسب الفريق ومتطلبات المنصة.

32. **Python ديناميكية:** ليست ثابتة وقت الترجمة.  
    **التطبيق العملي:** استخدام Type Hints وتقنيات فحص ثابت لتحسين الجودة.

33. **C# شائعة لتطوير .NET:** استخدام واسع.  
    **التطبيق العملي:** اعتمادها عند الاستثمار في بيئة .NET.

34. **Python لتحليل البيانات وتعلم الآلة:** وفرة مكتبات.  
    **التطبيق العملي:** توظيفها لخدمات التحليلات والنمذجة.

35. **Inversion of Control ليس من SOLID:** لكنه مبدأ بنيوي.  
    **التطبيق العملي:** استخدام الحاويات لحقن التبعيات بدل إنشائها داخليًا.

36. **Square كفرع من Rectangle قد ينتهك LSP:** سلوك غير متوافق.  
    **التطبيق العملي:** تجنّب الوراثة عندما تتعارض العقود.

37. **DIP:** الاعتماد على التجريدات لا التفاصيل.  
    **التطبيق العملي:** الخدمات تعتمد على واجهات مستودعات وليس على ORM مباشرة.

38. **Ports & Adapters = Hexagonal:** فصل المنافذ والمهايئات.  
    **التطبيق العملي:** عزل منطق المجال عن بنية التخزين أو الشبكة.

39. **Microkernel مناسب للإضافات:** نواة صغيرة قابلة للتوسعة.  
    **التطبيق العملي:** نظام تقارير يسمح بإضافة مولّدات جديدة عبر Plug-ins.

40. **Layered Architecture:** فصل المسؤوليات مع تكلفة عبور الطبقات.  
    **التطبيق العملي:** تجنّب طبقات زائدة غير ضرورية.

41. **Factory Method vs Abstract Factory:** أفراد مقابل عائلات كائنات.  
    **التطبيق العملي:** استخدام Abstract Factory عندما تحتاج مجموعة مترابطة.

42. **Decorator:** إضافة وظائف ديناميكيًا دون تعديل الأصل.  
    **التطبيق العملي:** تغليف خدمة لتفعيل كاش أو سجل.

43. **Observer في واجهات المستخدم:** عبر Listeners.  
    **التطبيق العملي:** ربط زر بمتعدد مستمعين لسيناريوهات مختلفة.

44. **مخاطر Singleton:** حالة عالمية خفية ومشاكل اختبار.  
    **التطبيق العملي:** قلّل استخدامه واعتمد DI بدلاً منه.

45. **Memento:** حفظ الحالة للاسترجاع.  
    **التطبيق العملي:** تنفيذ Undo في محرّر نصوص.

46. **Strategy vs State:** تبديل خوارزمية مقابل سلوك حسب الحالة.  
    **التطبيق العملي:** تسعير = Strategy، دورة حياة الطلب = State.

47. **Proxy:** وسيط للتحكم في الوصول.  
    **التطبيق العملي:** تأخير تهيئة كائن مكلف حتى الحاجة.

48. **Template Method:** هيكل خوارزمية مع خطوات مؤجلة.  
    **التطبيق العملي:** صنف أب يحدد سير المعالجة، والفروع تنفذ التفاصيل.

49. **قاعدة بيانات مستقلة لكل خدمة:** تقليل الاقتران.  
    **التطبيق العملي:** منع مشاركة مخطط قاعدة البيانات عبر الخدمات.

50. **التوسع العمودي vs الأفقي:** موارد الخادم مقابل زيادة الخوادم.  
    **التطبيق العملي:** استخدام الأفقي للتعامل مع الارتفاعات الحادة في الحمل.

51. **فوائد وعيوب Microservices:** نشر مستقل مقابل تعقيد تشغيل.  
    **التطبيق العملي:** تبنّيها عند الحاجة لتوسع مستقل حقيقي.

52. **Monolith قد يكون أفضل أولًا:** بساطة التطوير والنشر.  
    **التطبيق العملي:** البدء بمونوليث منظم قبل التفكيك.

53. **DDD:** نمذجة حسب المجال بالتعاون مع الخبراء.  
    **التطبيق العملي:** جلسات نمذجة مشتركة مع مالك المنتج.

54. **Bounded Context:** سياقات منفصلة لنماذج المجال.  
    **التطبيق العملي:** فصل السياق المالي عن سياق الشحن.

55. **Ubiquitous Language:** لغة مشتركة في التواصل والشيفرة.  
    **التطبيق العملي:** توحيد المصطلحات داخل الكود والوثائق.

56. **Network Flow Diagram ليس UML قياسيًا:** توضيح مهم.  
    **التطبيق العملي:** استخدامه كوثيقة مستقلة إن لزم.

57. **Code Review:** مراجعة زملاء لتحسين الجودة.  
    **التطبيق العملي:** فرض مراجعة لكل طلب دمج.

58. **Acceptance Testing:** تحقق من متطلبات العمل.  
    **التطبيق العملي:** اختبارات سيناريوهات المستخدم النهائية.

59. **Continuous Delivery vs Deployment:** قرار نشر بشري مقابل تلقائي.  
    **التطبيق العملي:** اعتماد Delivery في الأنظمة الحساسة.

60. **git merge:** دمج تغييرات فرع.  
    **التطبيق العملي:** دمج فرع ميزة بعد مراجعة واختبارات.

61. **Jenkins أداة CI وليس VCS:** توضيح الدور.  
    **التطبيق العملي:** استخدامه لتشغيل البِناء والاختبارات.

62. **Static Analysis:** فحص دون تشغيل.  
    **التطبيق العملي:** تشغيل تحليل ساكن في خط CI.

63. **Code Smell:** مؤشرات تصميم سيئ.  
    **التطبيق العملي:** علاج God Object عبر تقسيم المسؤوليات.

64. **Least Privilege:** أقل صلاحيات لازمة.  
    **التطبيق العملي:** حساب خدمة بحدود وصول محددة فقط.

65. **SQL Injection:** نتيجة إدخال غير معقم.  
    **التطبيق العملي:** استخدام Prepared Statements دائمًا.

66. **Defense in Depth:** طبقات متعددة من الحماية.  
    **التطبيق العملي:** WAF + مصادقة + مراقبة.

67. **Authentication vs Authorization:** تحقق هوية مقابل صلاحيات.  
    **التطبيق العملي:** فصل طبقة المصادقة عن طبقة السياسات.

68. **صنف متعدد المسؤوليات ينتهك SRP:** يحتاج تفكيك.  
    **التطبيق العملي:** تفكيك صنف ضخم إلى أصناف صغيرة.

69. **SOLID يحسن الصيانة والتوسع:** عبر تقليل الاقتران.  
    **التطبيق العملي:** مراجعة تصميمية دورية لضمان الالتزام.

70. **Layered vs Hexagonal:** تسلسل طبقات مقابل عزل المجال.  
    **التطبيق العملي:** اختيار Hexagonal عندما نحتاج مرونة تبديل البنى.

71. **Microservices vs Microkernel:** خدمات مستقلة مقابل نواة وإضافات.  
    **التطبيق العملي:** اختيار Microkernel للأنظمة القابلة للتوسعة.

72. **تحديات EDA:** تتبع وعدم فقد الرسائل.  
    **التطبيق العملي:** استخدام Correlation IDs ومستهلكين idempotent.

73. **Singleton نمط إنشائي:** من الـ Creational Patterns.  
    **التطبيق العملي:** توثيق سبب استخدامه بوضوح.

74. **تخفيف مخاطر Singleton:** DI وتقليل الحالة العالمية.  
    **التطبيق العملي:** بناء خدمات عديمة الحالة قدر الإمكان.

75. **Proxy للتحكم في الوصول:** تأخير/تخزين/صلاحيات.  
    **التطبيق العملي:** Proxy يضيف كاش لطلبات مكلفة.

76. **Template Method:** هيكل ثابت وخطوات متخصصة.  
    **التطبيق العملي:** معالجة ملفات عبر خطوات ثابتة.

77. **Strategy vs State (إعادة توكيد):** خوارزميات مقابل حالات.  
    **التطبيق العملي:** اختيار النمط المناسب حسب طبيعة التغيّر.

78. **Command:** تغليف الطلب في كائن.  
    **التطبيق العملي:** جدولة أو تنفيذ Undo للعمليات.

79. **High Availability:** تكرار وموازن حمل وFailover.  
    **التطبيق العملي:** إزالة نقطة الفشل الواحدة.

80. **متزامن vs غير متزامن:** انتظار مقابل عدم انتظار.  
    **التطبيق العملي:** استخدام غير متزامن للمهام الخلفية.

81. **Eventual Consistency:** اتساق نهائي مقبول أحيانًا.  
    **التطبيق العملي:** قبول التأخير في التقارير غير الحرجة.

82. **UML في الأجايل:** خفيف ومحدث عند الحاجة.  
    **التطبيق العملي:** مخططات مختصرة تدعم الحوار فقط.

83. **Bounded Context (إعادة توكيد):** حدود واضحة للنموذج.  
    **التطبيق العملي:** توثيق الحدود بين السياقات.

84. **Aggregate في DDD:** وحدة اتساق مع Root.  
    **التطبيق العملي:** تعديل الكيانات عبر Aggregate Root فقط.

85. **CI/CD يحسن الجودة والسرعة:** بناء واختبارات تلقائية.  
    **التطبيق العملي:** بوابات جودة تمنع إدخال كود معيب.

86. **Code Review الفعّالة:** تغييرات صغيرة ومعايير واضحة.  
    **التطبيق العملي:** قائمة تدقيق لكل مراجعة.

87. **مثال Code Smell:** دالة طويلة متعددة المسؤوليات.  
    **التطبيق العملي:** استخراج دوال صغيرة قابلة للاختبار.

88. **معالجة Technical Debt:** سداد تدريجي.  
    **التطبيق العملي:** تخصيص وقت ثابت في كل Sprint.

89. **Refactoring يحسن الصيانة:** دون تغيير السلوك.  
    **التطبيق العملي:** إعادة تنظيم بدون تعديل المخرجات.

90. **تجنب SQL Injection:** Prepared Statements وLeast Privilege.  
    **التطبيق العملي:** مراجعة كل استعلام ديناميكي.

91. **تخفيف DDoS:** CDN وWAF وRate Limiting.  
    **التطبيق العملي:** إعداد قواعد حماية وتوسع تلقائي.

92. **ثلاثية CIA:** سرية وتكامل وتوافر.  
    **التطبيق العملي:** تقييم أي ميزة وفق هذه الثلاثية.

93. **Spring وASP.NET Core:** أطر تسرّع التطوير.  
    **التطبيق العملي:** اعتماد إطار عند الحاجة لمزايا جاهزة.

94. **.NET تدعم تعددية اللغات:** C# وF# وVB.NET.  
    **التطبيق العملي:** اختيار اللغة حسب المجال داخل نفس المنصة.

95. **Dependency Injection:** حقن التبعيات بدل إنشائها داخليًا.  
    **التطبيق العملي:** تسهيل الاختبار عبر حقن بدائل وهمية.

96. **إدارة الذاكرة:** GC في Java/C# مقابل يدوي في C++.  
    **التطبيق العملي:** الموازنة بين الأداء وسلامة الذاكرة.

97. **JVM وCLR:** تشغيل عبر Bytecode/IL وJIT.  
    **التطبيق العملي:** توقع سلوك الأداء مع الترجمة وقت التشغيل.

98. **الأداء مقابل سرعة التطوير:** C++/Rust للأداء، Python للسرعة.  
    **التطبيق العملي:** اختيار التقنية وفق احتياجات المشروع.

99. **تشغيل C# عبر IL وCLR على أنظمة متعددة:** قابلية نقل.  
    **التطبيق العملي:** نشر الخدمة على لينكس عند توفر runtime.

100. **JVM تستخدم JIT لتحسين الأداء:** ترجمة وقت التشغيل.  
    **التطبيق العملي:** مراقبة الأداء بعد الإحماء (warm-up).

---

## تطبيق عميق للمبادئ على المشروع (خارطة تنفيذية احترافية)

> هذا القسم يربط المبادئ مع القرارات اليومية في التصميم والتنفيذ والاختبار والتشغيل داخل هذا المستودع.

### 1) نواة النظام كمسار وظيفي واضح (Functional Core, Imperative Shell)
- **القاعدة:** اجعل منطق المجال في دوال نقية تُستدعى من طبقات حدودية (I/O).  
- **التطبيق:** أي تفاعل مع الشبكة/القرص/القواعد يبقى في حواف النظام، بينما تُبنى القواعد داخل دوال مستقلة قابلة للاختبار.  
- **مؤشر الالتزام:** اختبارات الوحدة تغطي المنطق دون الحاجة لبنية تشغيل خارجية.

### 2) عزل الخدمات المصغّرة فعليًا وليس نظريًا
- **القاعدة:** كل خدمة في `microservices/` هي جزيرة مستقلة.  
- **التطبيق:** لا استدعاء مباشر لقاعدة بيانات خدمة أخرى، ولا مشاركة منطق أعمال عبر مكتبات مشتركة.  
- **مؤشر الالتزام:** أي تكامل يتم عبر HTTP/gRPC أو أحداث، وليس مشاركة جداول أو طبقات ORM.

### 3) تطبيق SRP عبر تقسيم واضح للمسؤوليات
- **القاعدة:** الصنف/الوحدة لا يُغير إلا لسبب واحد.  
- **التطبيق:** عندما ترى ملفًا يجمع بين تحويل البيانات والتحقق والتخزين، افصل كل مسؤولية في وحدة منفصلة.  
- **مؤشر الالتزام:** كل ملف لديه مهمة محددة وواضحة ومختبرة.

### 4) تطبيق OCP عبر التوسعة لا التعديل
- **القاعدة:** التعديل يكون بإضافة وحدات جديدة لا بفتح منطق قائم.  
- **التطبيق:** استخدم واجهات Strategy/Factory لإضافة سياسات جديدة (مثلاً قواعد تسعير/تحقق).  
- **مؤشر الالتزام:** إضافة ميزة جديدة لا يتطلب تعديل مسارات التنفيذ الأساسية.

### 5) DRY دون كسر الاستقلالية
- **القاعدة:** لا تكرار داخل الخدمة نفسها، لكن لا تنقل منطق أعمال مشترك بين الخدمات.  
- **التطبيق:** كرّر منطق الأعمال بين الخدمات عند الحاجة للحفاظ على استقلالية الخدمات، وقلّل التكرار داخل نفس الخدمة عبر وحدات مشتركة محلية.  
- **مؤشر الالتزام:** لا توجد مكتبات أعمال مشتركة عابرة للخدمات.

### 6) KISS وYAGNI كفلتر قرار يومي
- **القاعدة:** البساطة أولًا وعدم بناء ما لا تحتاجه.  
- **التطبيق:** لا تُدخل طبقة جديدة أو نظام Plug-in إلا عندما تظهر متطلبات مؤكدة، وليس توقعات.  
- **مؤشر الالتزام:** كل تعقيد له سبب تشغيلي واضح ومثبت.

### 7) Layered Architecture دون تكديس طبقات
- **القاعدة:** كل طبقة تتعامل مع الطبقة التي تحتها مباشرة.  
- **التطبيق:** واجهة/تحكم → خدمات مجال → مستودعات/بوابات تكامل.  
- **مؤشر الالتزام:** لا يوجد استدعاء مباشر من الواجهة إلى التخزين.

### 8) Event-Driven Architecture لفك الترابط
- **القاعدة:** الأحداث تنقل النية لا التنفيذ.  
- **التطبيق:** صغ رسائل حدث صغيرة ودلالية مع `Correlation ID` لتتبع المسار.  
- **مؤشر الالتزام:** تعطل مستهلك حدث لا يكسر المنتج الأساسي.

### 9) DIP لعزل التفاصيل التقنية
- **القاعدة:** منطق الأعمال يعتمد على تجريدات لا تفاصيل.  
- **التطبيق:** اجعل الطبقة العليا تتعامل مع واجهات، ثم وفّر تنفيذات للبنية التحتية.  
- **مؤشر الالتزام:** استبدال قاعدة بيانات لا يتطلب تغيير منطق الأعمال.

### 10) استراتيجية اختبار متدرجة واقعية
- **القاعدة:** وحدة → تكامل → قبول.  
- **التطبيق:**  
  - **Unit:** اختبارات نقية لمنطق المجال.  
  - **Integration:** التحقق من تكامل الخدمات والبوابات.  
  - **Acceptance:** سيناريوهات عمل حقيقية.  
- **مؤشر الالتزام:** كل طبقة اختبار تمتلك هدفًا محددًا ولا تكرر دور الطبقات الأخرى.

### 11) الأمن كقيد تصميمي دائم
- **القاعدة:** لا تخزين لبيانات حساسة بدون تشفير/هاش.  
- **التطبيق:** TLS للاتصال، وHash لكلمات المرور، وLeast Privilege لكل حساب.  
- **مؤشر الالتزام:** أي وحدة تخزين تحتوي على سياسة حماية واضحة ومراجَعة.

### 12) الاتساق النهائي بوعي
- **القاعدة:** الاتساق النهائي خيار معماري وليس حادثًا.  
- **التطبيق:** استخدمه فقط عند قبول تأخير البيانات مع توثيق ذلك للمستخدمين.  
- **مؤشر الالتزام:** توجد رسائل توضيحية في عمليات التقارير والتزامن.

### 13) سياسات تشغيل عالية التوفر
- **القاعدة:** لا نقطة فشل واحدة.  
- **التطبيق:** موازن حمل + تكرار خدمات حرجة + مراقبة.  
- **مؤشر الالتزام:** فشل مثيل واحد لا يوقف الخدمة.

### 14) مراجعة الكود كحاجز جودة
- **القاعدة:** كل تعديل يجب أن يكون صغيرًا وقابلًا للفحص.  
- **التطبيق:** قائمة تدقيق ثابتة تشمل: SRP/OCP، الأمن، الاختبارات.  
- **مؤشر الالتزام:** لا دمج بدون اختبارات أو مراجعة.

### 15) توثيق حيّ ومباشر
- **القاعدة:** التوثيق يصف السلوك وليس الشعار.  
- **التطبيق:** أي تغيير في بنية النظام يُوثّق مباشرة في `docs/architecture`.  
- **مؤشر الالتزام:** الوثائق تسبق أو تواكب التغيير.

---

## المبادئ الصارمة للنظام (ملخّص إلزامي شامل)

> هذا القسم مُلزم ويُطبَّق على كامل الشيفرة والوثائق والاختبارات والبنية المعمارية. أي مساهمة يجب أن تلتزم بهذه المبادئ دون استثناء.

1. تعدد الأشكال في البرمجة كائنية التوجه يسمح بواجهة واحدة لاستدعاء عمليات متعددة حسب نوع الكائن وقت التنفيذ.
2. لا يمكن إنشاء كائن (Instance) مباشرةً من فئة مجردة (Abstract Class).
3. الوراثة تتيح إعادة استخدام الشيفرة عبر إنشاء فئة جديدة تعتمد على خصائص وسلوك فئة موجودة.
4. التغليف (Encapsulation) يعني إخفاء التفاصيل الداخلية للكائن وإظهار واجهة محددة للتعامل معه.
5. الدالة النقية لا تقوم بتعديل متغيرات عامة أو إحداث تأثيرات جانبية على حالة خارجية.
6. الدالة عالية الرتبة (Higher-Order Function) هي دالة تأخذ دوالًا كوسائط أو تُرجع دالة كنتيجة.
7. التقييم الكسول (Lazy Evaluation) يعني تأجيل حساب التعبير حتى الحاجة الفعلية لقيمته.
8. عدم قابلية التغيير (Immutability) يساعد على تجنب الاعتماد على حالة متغيرة أثناء التنفيذ كما في البرمجة الوظيفية.
9. الكومة الثنائية (Binary Heap) مناسبة لتنفيذ صف ذي أولوية (Priority Queue) للحصول على أعلى أولوية بكفاءة.
10. بنية Trie (Prefix Tree) تخزن الكلمات حسب البادئات وتتيح البحث بكفاءة اعتمادًا على البادئة.
11. البحث بعرض (BFS) يستخدم صفًّا (Queue) لزيارة العقد مستوىً بمستوى.
12. جدول التجزئة (Hash Table) يخزن أزواج المفتاح/القيمة ويتيح بحثًا بمتوسط زمن قريب من ‎O(1)‎.
13. شجرة AVL هي شجرة بحث ثنائية ذاتية الاتزان تضمن عمليات ‎O(log n)‎ في أسوأ الأحوال.
14. البرمجة الديناميكية (Dynamic Programming) تحل المشكلة عبر مشاكل فرعية وتخزن النتائج لتجنب إعادة الحساب.
15. خوارزمية Backtracking تبني الحل تدريجيًا وتتراجع عند اكتشاف أن المسار الحالي لن يؤدي إلى حل صحيح.
16. تعقيد البحث الثنائي (Binary Search) في قائمة مرتبة هو ‎O(log n)‎.
17. الخوارزميات الجشعة (Greedy) تتخذ قرارًا محليًا أفضل في كل خطوة على أمل الوصول لحل عالمي جيد.
18. حالة السباق (Race Condition) تحدث عندما تتنافس خيوط متعددة على مورد مشترك فتنتج نتائج غير متوقعة.
19. خيوط العملية الواحدة تشترك في نفس مساحة الذاكرة، بينما العمليات المنفصلة تملك ذاكرة معزولة.
20. القفل (Mutex) يمنع دخول أكثر من خيط إلى القسم الحرج في الوقت نفسه ويساعد على منع السباقات.
21. Singleton مثال على نمط تصميم من أنماط عصابة الأربعة (GoF).
22. نمط Observer يقوم فيه الـSubject بإخطار الـObservers عند تغيّر حالته.
23. مبادئ SOLID الخمسة تهدف لتحسين قابلية الفهم والتطوير والصيانة في التصميم الكائني.
24. نظرية CAP تشير إلى: الاتساق (Consistency) والتوافرية (Availability) وتحمل التقسيم (Partition Tolerance).
25. RPC يسمح باستدعاء إجراء على خادم بعيد كما لو كان استدعاءً محليًا.
26. طوابير الرسائل تفصل المكونات عبر تواصل غير متزامن وتمكّن اختلاف سرعات المنتج والمستهلك دون فقد البيانات.
27. Git نظام تحكم إصدارات موزع لتتبع وإدارة تاريخ الشيفرة المصدرية.
28. Docker يوفّر حاويات لتشغيل التطبيق مع تبعياته في بيئة معزولة تشارك نواة النظام المضيف.
29. CI/CD تعني التكامل المستمر والتسليم المستمر (وأحيانًا النشر المستمر).
30. Haskell تُعد لغة وظيفية خالصة (Purely Functional) بشكل افتراضي مع تقييم كسول.
31. جعل Square يرث من Rectangle مع تغيير سلوك setWidth/setHeight يخرق مبدأ استبدال ليسكوف (LSP) لأنه يمنع الاستبدال الآمن.
32. مبدأ Open/Closed ينص على أن الكيانات البرمجية مفتوحة للإضافة ومغلقة للتعديل.
33. Java لا تدعم الوراثة المتعددة للفئات مباشرةً لتجنب غموض مشكلة الماس.
34. مبدأ Dependency Inversion يفرض أن تعتمد الوحدات على التجريدات لا على التفاصيل، وأن تعتمد التفاصيل أيضًا على التجريدات.
35. الدالة عديمة الآثار الجانبية لا تغيّر حالة خارجية (مثل متغير عام أو ملف أو طباعة)، وهذا يجعلها أسهل للاختبار والتوازي والتنبؤ.
36. التقييم الكسول في Haskell يسمح بتعريف بنى بيانات لانهائية لأن القيم لا تُحسب إلا عند الحاجة.
37. العودية (Recursion) تُستخدم كثيرًا بدل الحلقات في البرمجة الوظيفية.
38. عقدة B-Tree قد تحتوي عدة مفاتيح وعدة أبناء، ما يقلل ارتفاع الشجرة مقارنةً بـBST.
39. Trie هي الأنسب للبحث بحسب بادئة نصية كما في الإكمال التلقائي.
40. خوارزمية Dijkstra لا تعمل بشكل صحيح بوجود أوزان سالبة.
41. معالجة تصادمات Hash يمكن أن تتم عبر Chaining (قائمة/بنية لكل خانة) أو Open Addressing (البحث عن خانة بديلة وفق نمط).
42. البرمجة الديناميكية تتطلب Optimal Substructure وتداخل المشاكل الفرعية (Overlapping Subproblems).
43. الخوارزمية التقريبية لمسألة NP-صعبة قد لا تعطي الحل الأمثل لكنها تضمن حدًا/نسبة تقريب بالنسبة للأمثل.
44. الشيفرة ذات الحلقة المثلثية (j من 1 إلى i) تعقيدها الكلي من رتبة ‎O(n^2)‎.
45. QuickSort متوسطه ‎O(n log n)‎ وقد يصبح ‎O(n^2)‎ في أسوأ الحالات عند اختيار Pivot سيئ باستمرار.
46. Deadlock يحدث عندما تنتظر خيوط متعددة موارد يحتجزها بعضها البعض بشكل دائري فلا يتقدم أي خيط.
47. نموذج Actor يعتمد على تمرير الرسائل دون مشاركة حالة مباشرة بين المكونات.
48. مثال Race Condition: خيطان يزيدان counter في نفس الوقت فيضيع أحد التحديثين، ويُمنع ذلك بقفل Mutex أو عمليات ذرّية (Atomic).
49. Concurrency تعني تداخل المهام منطقيًا، وParallelism تعني تنفيذها فعليًا في نفس اللحظة على أكثر من نواة/معالج.
50. نمط Strategy يتيح تبديل خوارزميات قابلة للتبادل أثناء التشغيل دون تغيير الكود العميل.
51. Reactive Programming تعتمد على تدفقات بيانات غير متزامنة تنشر التغيّرات تلقائيًا للمشتركين.
52. MVC يفصل Model عن View وعن Controller لتحسين التنظيم والصيانة.
53. Eventual Consistency تعني أن العقد ستتوافق في النهاية إذا توقفت التحديثات الجديدة.
54. 2PC يضمن ذرّية المعاملة الموزعة بحيث تُعتمد لدى الجميع أو تُلغى لدى الجميع وفق قرار منسّق.
55. Strong Consistency تضمن رؤية أحدث كتابة فورًا، بينما Eventual Consistency قد تُظهر قراءات قديمة مؤقتًا ثم تتقارب لاحقًا.
56. زمن الشبكة (Latency) قد يؤثر بشدة على أداء وصحة الأنظمة الموزعة ويجب تصميم النظام مع افتراض وجود تأخير.
57. VM تشغّل نظام تشغيل كاملًا لكل آلة افتراضية، بينما Container يشغّل التطبيق وتبعياته مع مشاركة نواة المضيف وبكلفة أخف.
58. Kubernetes منصة شائعة لأتمتة نشر وإدارة حاويات Docker مع التوسع والتعافي الذاتي.
59. CI يدمج ويختبر باستمرار، وCD يجهّز النشر باستمرار (أو ينشر تلقائيًا في حالة Continuous Deployment).
60. Profiling يقيس استهلاك الموارد لتحديد اختناقات الأداء مثل دوال تستهلك أكثر وقت CPU أو ذاكرة.
61. Design by Contract يحدد شروطًا مسبقة ولاحقة وثوابت صنف لضمان صحة السلوك ورفع موثوقية البرمجية.
62. مشكلة الماس في الوراثة المتعددة تنشأ عندما تتقاطع وراثتان من أصل مشترك فتظهر إشكالية أي نسخة من الأساس تُستخدم.
63. الشيفرة C++ ستطبع “Derived” لأن foo افتراضية وسيتم الربط ديناميكيًا حسب النوع الفعلي للكائن.
64. مبدأ Interface Segregation ينص على ألا يُجبر العملاء على الاعتماد على واجهات لا يحتاجونها.
65. مبدأ المسؤولية الواحدة (SRP) يعني أن لكل صنف سببًا واحدًا للتغيير مما يقلل التعقيد ويزيد قابلية الصيانة.
66. الموناد (Monad) هي بنية تربط عمليات في سياق (مثل Maybe أو IO) عبر bind/return لتسلسل العمليات دون معالجة السياق يدويًا كل مرة.
67. Eager Evaluation يحسب القيم فورًا وهو أسهل للتنبؤ بالأداء، بينما Lazy Evaluation يؤجل الحساب وقد يوفر عملًا لكنه قد يصعّب توقع الذاكرة والزمن.
68. الدوال النقية والبيانات غير القابلة للتغيير تسهّل التوازي لأن غياب الآثار الجانبية يقلل الحاجة للتزامن.
69. Tail Recursion Optimization يحول الاستدعاء الذاتي الأخير إلى شكل حلقي لتقليل استهلاك المكدس ومنع Stack Overflow.
70. التعبير take 5 (iterate (+1) 0) ينتج [0,1,2,3,4] لأن iterate تولد قائمة لانهائية وtake يأخذ أول خمسة عناصر فقط.
71. Trie مناسبة للإكمال التلقائي لأنها تجعل زمن البحث مرتبطًا بطول البادئة وتسمح باستعراض كل الكلمات تحت عقدة البادئة.
72. Hash Table متوسطه ‎O(1)‎ لكن أسوأه قد يصل ‎O(n)‎، بينما الشجرة المتوازنة تضمن ‎O(log n)‎ في أسوأ الحالات.
73. Trie قد تستهلك ذاكرة أكبر عندما تكون مجموعة الكلمات كبيرة والتشارك في البادئات قليل.
74. B-Tree ذات تفرع عالٍ تقلل عمق الشجرة وعدد عمليات I/O على القرص لذا تناسب قواعد البيانات والتخزين الخارجي.
75. أفضل نهج لاستخراج أكبر 10 قيم من مليون عنصر هو الاحتفاظ بـMin-Heap بحجم 10 أثناء المرور لتحقيق ‎O(n log 10)‎.
76. NP-Complete تعني أن المسألة في NP وكل مسائل NP يمكن اختزالها إليها، ولا يُعرف حل متعدد الحدود لها عمومًا.
77. Memoization أسلوب Top-Down مع كاش لنتائج الاستدعاءات العودية، وTabulation أسلوب Bottom-Up يبني جدولًا من الحالات الأصغر للأكبر.
78. إذا تضاعف n وزاد الزمن إلى 8× فالتعقيد المرجح هو ‎O(n^3)‎.
79. مثال خوارزمية تقريبية: Vertex Cover بخوارزمية تقريب 2-Approx التي تختار طرفي ضلع غير مغطى وتكرر حتى تغطية كل الأضلاع.
80. Bellman-Ford تصلح لإيجاد أقصر مسارات مع أوزان سالبة طالما لا توجد دورات سالبة.
81. Semaphore يدير عددًا من “التصاريح” لمورد محدود، بينما Mutex قفل حصري لمورد واحد عادةً؛ مثلًا Semaphore بقيمة 3 يحد عدد الاتصالات المتزامنة إلى 3.
82. Data Parallelism يعني نفس العملية على أجزاء بيانات مختلفة (مثل جمع أجزاء مصفوفة)، وTask Parallelism يعني مهام مختلفة بالتوازي (مثل معالجة لون الصورة وتطبيق فلتر في آن واحد).
83. قانون أمدال يحدد حدًا أعلى للتسريع بسبب الجزء المتسلسل الذي لا يمكن موازنته بالكامل.
84. GIL في CPython يمنع تنفيذ بايت كود بايثون في أكثر من خيط في نفس الوقت داخل نفس العملية، ما يحد من توازي المهام الحسابية.
85. Go تستخدم goroutines خفيفة وChannels للتواصل بأسلوب مستوحى من CSP عبر تمرير الرسائل بدل مشاركة الذاكرة.
86. Clean Architecture تعزل منطق الأعمال في الداخل وتفرض قاعدة الاعتماد بأن تتجه الاعتماديات نحو الداخل فقط لا نحو التفاصيل الخارجية.
87. Backpressure آلية لضبط تدفق البيانات عندما يكون المستهلك أبطأ من المنتج لتجنب الانهيار أو نفاد الذاكرة.
88. Dependency Injection يحقق DIP عمليًا بتمرير التبعيات من الخارج بدل إنشائها داخليًا، مما يقلل الاقتران ويسهّل الاختبار.
89. نمط Visitor يسمح بإضافة عمليات جديدة على كائنات متعددة دون تعديل تعريف هذه الكائنات عبر “زائر” ينفذ العمليات عليها.
90. Loose Coupling يعني اعتمادًا ضعيفًا بين المكونات عبر واجهات وتجريدات بحيث يمكن تغيير جزء دون كسر بقية النظام.
91. ACID يركز على الذرية والاتساق والعزل والدوام، بينما BASE يركز على التوافر الأساسي والحالة المرنة والاتساق النهائي في بعض NoSQL.
92. 2PC يعمل بمرحلة Prepare للتصويت ثم مرحلة Commit/Abort لضمان أن الجميع يلتزم أو الجميع يتراجع.
93. نظام مصرفي غالبًا يفضل CP (اتساق + تحمل تقسيم) حتى لو ضحّى بالتوافرية أثناء الانقسام لتجنب أخطاء مالية.
94. Message Queue تفصل الخدمات وتزيد المرونة والتوسع عبر تخزين الرسائل ومعالجتها لاحقًا وتمكين زيادة عدد المستهلكين عند الذروة.
95. Idempotence مهمة لأنها تسمح بإعادة إرسال الطلبات أو تكرار التنفيذ عند الفشل دون مضاعفة الأثر النهائي.
96. git merge يدمج التاريخ مع Merge Commit ويحافظ على التشعب، بينما git rebase يعيد كتابة التاريخ ليصبح خطيًا ويُفضّل على الفروع الخاصة قبل مشاركتها.
97. Kubernetes يوفّر Self-healing بإعادة تشغيل الحاويات أو إعادة جدولة Pods عند الفشل للحفاظ على توفر الخدمة.
98. Blue-Green Deployment يستخدم بيئتين متطابقتين ويحوّل المرور من القديمة للجديدة دفعة واحدة لتقليل التوقف وتسهيل الرجوع السريع.
99. Distributed Tracing يربط الطلب عبر الخدمات باستخدام Trace ID وSpans ليُظهر أين حدث التأخير أو الخطأ داخل سلسلة الخدمات.
100. Logging وMonitoring وDistributed Tracing تشكل معًا أعمدة Observability لفهم الحالة الداخلية للنظام وتشخيص الأعطال بسرعة.
